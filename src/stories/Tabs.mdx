import * as UI from '../../src/index'
import * as TabsStories from './Tabs.stories';

import { Canvas, Meta, Story } from "@storybook/blocks";
import { action } from "@storybook/addon-actions";

<Meta of={TabsStories} />

export const loadTurtleDecorator = (Story) => {
  const { render, data } = Story();
  $rdf.parse(data, SolidLogic.store, location.origin, "text/turtle", (error) => {
    if (error) console.error(error);
  });
  const div = document.createElement("div");
  const pre = document.createElement("pre");
  pre.appendChild(document.createTextNode(data));
  div.appendChild(pre);
  div.appendChild(render());
  return div;
};

## tabWidget: Populating content using an RDF collection

In this first example we'll see how you can generate a tabs widget using triples that are formatted as a collection in
RDF. See [API docs](https://solidos.github.io/solid-ui/docs/api/modules/_tabs_.html#tabwidget) for more
info about how to use the tabWidget.

The triples belows shows the minimum data you need to start using the tabWidget in combination with store.

<Canvas>
  <Story of={TabsStories.RdfCollection} />
</Canvas>

Note that you would probably use `$rdf.namedNode` directly from rdflib.js. (E.g. instead of
`$rdf.namedNode` you would probably make use of namedNode with
`import { namedNode } from 'rdflib'`.

## tabWidget: Populating content using unsorted triples

In this second example we'll use an unsorted set of triples instead of a collection.

This is the data we will be working with. Note that we've also added labels to the items to help the widget know how to label the tabs.

Note that we've set option ordered to false in this example.

<Canvas>
  <Story of={TabsStories.UnsortedTriples} />
</Canvas>

## tabWidget: Populating content using option items

Finally we can set the items manually by using option items.

We do not need to use options subject and predicate when using items.

<Canvas>
  <Story of={TabsStories.OptionItems} />
</Canvas>

â„¹ For the remaining examples we'll use option items to populate our tabs.

## tabWidget: Option backgroundColor

Using option `backgroundColor` we can set a specific color (in hex value) to our tabs. It will consider how light a
color is when figuring out which color to set to the text. It will also distinguish between selected and not selected
tabs by coloring the selected tab a bit darker.

<Canvas>
  <Story of={TabsStories.BackgroundColor} />
</Canvas>

## tabWidget: Option onClose

<Canvas>
  <Story of={TabsStories.OnClose} />
</Canvas>

## tabWidget: Option orientation

Using option `orientation` we can set how the tabs and body should be positioned.

<Canvas>
  <Story of={TabsStories.Orientation} />
</Canvas>

## tabWidget: Option renderTab

`renderTab` allows us to override the default behavior for how tabs are rendered, e.g. which text should be shown for each tab.

<Canvas>
  <Story of={TabsStories.RenderTab} />
</Canvas>

## tabWidget: Option renderTabSettings

`renderTabSettings` functions much like `renderMain`, expect that it is triggered by holding ALT key (Option key on Mac
) and clicking on a tab.

<Canvas>
  <Story of={TabsStories.RenderTabSettings} />
</Canvas>

## tabWidget: Option selectedTab

`selectedTab` allows you to set which tab should be opened by when the widget is initially rendered. It must be used
in junction with `renderTab` since it relies on `dataset.name` being set.

<Canvas>
  <Story of={TabsStories.SelectedTab} />
</Canvas>

## tabWidget: Option startEmpty

`startEmpty` makes it so that the body of a tab isn't shown when initially rendered.

<Canvas>
  <Story of={TabsStories.StartEmpty} />
</Canvas>
