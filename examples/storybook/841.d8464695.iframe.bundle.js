/*! For license information please see 841.d8464695.iframe.bundle.js.LICENSE.txt */
(self.webpackChunksolid_ui=self.webpackChunksolid_ui||[]).push([[841],{"./node_modules/canonicalize/lib/canonicalize.js":module=>{"use strict";module.exports=function serialize(object){return null===object||"object"!=typeof object||null!=object.toJSON?JSON.stringify(object):Array.isArray(object)?"["+object.reduce(((t,cv,ci)=>t+(0===ci?"":",")+serialize(void 0===cv||"symbol"==typeof cv?null:cv)),"")+"]":"{"+Object.keys(object).sort().reduce(((t,cv,ci)=>{if(void 0===object[cv]||"symbol"==typeof object[cv])return t;return t+(0===t.length?"":",")+serialize(cv)+":"+serialize(object[cv])}),"")+"}"}},"./node_modules/jsonld/lib/ContextResolver.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";const{isArray:_isArray,isObject:_isObject,isString:_isString}=__webpack_require__("./node_modules/jsonld/lib/types.js"),{asArray:_asArray}=__webpack_require__("./node_modules/jsonld/lib/util.js"),{prependBase}=__webpack_require__("./node_modules/jsonld/lib/url.js"),JsonLdError=__webpack_require__("./node_modules/jsonld/lib/JsonLdError.js"),ResolvedContext=__webpack_require__("./node_modules/jsonld/lib/ResolvedContext.js");function _throwInvalidLocalContext(ctx){throw new JsonLdError("Invalid JSON-LD syntax; @context must be an object.","jsonld.SyntaxError",{code:"invalid local context",context:ctx})}function _resolveContextUrls({context,base}){if(!context)return;const ctx=context["@context"];if(_isString(ctx))context["@context"]=prependBase(base,ctx);else if(_isArray(ctx))for(let i=0;i<ctx.length;++i){const element=ctx[i];_isString(element)?ctx[i]=prependBase(base,element):_isObject(element)&&_resolveContextUrls({context:{"@context":element},base})}else if(_isObject(ctx))for(const term in ctx)_resolveContextUrls({context:ctx[term],base})}module.exports=class ContextResolver{constructor({sharedCache}){this.perOpCache=new Map,this.sharedCache=sharedCache}async resolve({activeCtx,context,documentLoader,base,cycles=new Set}){context&&_isObject(context)&&context["@context"]&&(context=context["@context"]),context=_asArray(context);const allResolved=[];for(const ctx of context){if(_isString(ctx)){let resolved=this._get(ctx);resolved||(resolved=await this._resolveRemoteContext({activeCtx,url:ctx,documentLoader,base,cycles})),_isArray(resolved)?allResolved.push(...resolved):allResolved.push(resolved);continue}if(null===ctx){allResolved.push(new ResolvedContext({document:null}));continue}_isObject(ctx)||_throwInvalidLocalContext(context);const key=JSON.stringify(ctx);let resolved=this._get(key);resolved||(resolved=new ResolvedContext({document:ctx}),this._cacheResolvedContext({key,resolved,tag:"static"})),allResolved.push(resolved)}return allResolved}_get(key){let resolved=this.perOpCache.get(key);if(!resolved){const tagMap=this.sharedCache.get(key);tagMap&&(resolved=tagMap.get("static"),resolved&&this.perOpCache.set(key,resolved))}return resolved}_cacheResolvedContext({key,resolved,tag}){if(this.perOpCache.set(key,resolved),void 0!==tag){let tagMap=this.sharedCache.get(key);tagMap||(tagMap=new Map,this.sharedCache.set(key,tagMap)),tagMap.set(tag,resolved)}return resolved}async _resolveRemoteContext({activeCtx,url,documentLoader,base,cycles}){url=prependBase(base,url);const{context,remoteDoc}=await this._fetchContext({activeCtx,url,documentLoader,cycles});_resolveContextUrls({context,base:base=remoteDoc.documentUrl||url});const resolved=await this.resolve({activeCtx,context,documentLoader,base,cycles});return this._cacheResolvedContext({key:url,resolved,tag:remoteDoc.tag}),resolved}async _fetchContext({activeCtx,url,documentLoader,cycles}){if(cycles.size>10)throw new JsonLdError("Maximum number of @context URLs exceeded.","jsonld.ContextUrlError",{code:"json-ld-1.0"===activeCtx.processingMode?"loading remote context failed":"context overflow",max:10});if(cycles.has(url))throw new JsonLdError("Cyclical @context URLs detected.","jsonld.ContextUrlError",{code:"json-ld-1.0"===activeCtx.processingMode?"recursive context inclusion":"context overflow",url});let context,remoteDoc;cycles.add(url);try{remoteDoc=await documentLoader(url),context=remoteDoc.document||null,_isString(context)&&(context=JSON.parse(context))}catch(e){throw new JsonLdError(`Dereferencing a URL did not result in a valid JSON-LD object. Possible causes are an inaccessible URL perhaps due to a same-origin policy (ensure the server uses CORS if you are using client-side JavaScript), too many redirects, a non-JSON response, or more than one HTTP Link Header was provided for a remote context. URL: "${url}".`,"jsonld.InvalidUrl",{code:"loading remote context failed",url,cause:e})}if(!_isObject(context))throw new JsonLdError(`Dereferencing a URL did not result in a JSON object. The response was valid JSON, but it was not a JSON object. URL: "${url}".`,"jsonld.InvalidUrl",{code:"invalid remote context",url});return context="@context"in context?{"@context":context["@context"]}:{"@context":{}},remoteDoc.contextUrl&&(_isArray(context["@context"])||(context["@context"]=[context["@context"]]),context["@context"].push(remoteDoc.contextUrl)),{context,remoteDoc}}}},"./node_modules/jsonld/lib/JsonLdError.js":module=>{"use strict";module.exports=class JsonLdError extends Error{constructor(message="An unspecified JSON-LD error occurred.",name="jsonld.Error",details={}){super(message),this.name=name,this.message=message,this.details=details}}},"./node_modules/jsonld/lib/JsonLdProcessor.js":module=>{"use strict";module.exports=jsonld=>{class JsonLdProcessor{toString(){return"[object JsonLdProcessor]"}}return Object.defineProperty(JsonLdProcessor,"prototype",{writable:!1,enumerable:!1}),Object.defineProperty(JsonLdProcessor.prototype,"constructor",{writable:!0,enumerable:!1,configurable:!0,value:JsonLdProcessor}),JsonLdProcessor.compact=function(input,ctx){return arguments.length<2?Promise.reject(new TypeError("Could not compact, too few arguments.")):jsonld.compact(input,ctx)},JsonLdProcessor.expand=function(input){return arguments.length<1?Promise.reject(new TypeError("Could not expand, too few arguments.")):jsonld.expand(input)},JsonLdProcessor.flatten=function(input){return arguments.length<1?Promise.reject(new TypeError("Could not flatten, too few arguments.")):jsonld.flatten(input)},JsonLdProcessor}},"./node_modules/jsonld/lib/NQuads.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";module.exports=__webpack_require__("./node_modules/rdf-canonize/index.js").NQuads},"./node_modules/jsonld/lib/RequestQueue.js":module=>{"use strict";module.exports=class RequestQueue{constructor(){this._requests={}}wrapLoader(loader){const self=this;return self._loader=loader,function(){return self.add.apply(self,arguments)}}async add(url){let promise=this._requests[url];if(promise)return Promise.resolve(promise);promise=this._requests[url]=this._loader(url);try{return await promise}finally{delete this._requests[url]}}}},"./node_modules/jsonld/lib/ResolvedContext.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";const LRU=__webpack_require__("./node_modules/jsonld/node_modules/lru-cache/index.js");module.exports=class ResolvedContext{constructor({document}){this.document=document,this.cache=new LRU({max:10})}getProcessed(activeCtx){return this.cache.get(activeCtx)}setProcessed(activeCtx,processedCtx){this.cache.set(activeCtx,processedCtx)}}},"./node_modules/jsonld/lib/compact.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";const JsonLdError=__webpack_require__("./node_modules/jsonld/lib/JsonLdError.js"),{isArray:_isArray,isObject:_isObject,isString:_isString,isUndefined:_isUndefined}=__webpack_require__("./node_modules/jsonld/lib/types.js"),{isList:_isList,isValue:_isValue,isGraph:_isGraph,isSimpleGraph:_isSimpleGraph,isSubjectReference:_isSubjectReference}=__webpack_require__("./node_modules/jsonld/lib/graphTypes.js"),{expandIri:_expandIri,getContextValue:_getContextValue,isKeyword:_isKeyword,process:_processContext,processingMode:_processingMode}=__webpack_require__("./node_modules/jsonld/lib/context.js"),{removeBase:_removeBase,prependBase:_prependBase}=__webpack_require__("./node_modules/jsonld/lib/url.js"),{REGEX_KEYWORD,addValue:_addValue,asArray:_asArray,compareShortestLeast:_compareShortestLeast}=__webpack_require__("./node_modules/jsonld/lib/util.js"),api={};function _checkNestProperty(activeCtx,nestProperty,options){if("@nest"!==_expandIri(activeCtx,nestProperty,{vocab:!0},options))throw new JsonLdError("JSON-LD compact error; nested property must have an @nest value resolving to @nest.","jsonld.SyntaxError",{code:"invalid @nest value"})}module.exports=api,api.compact=async({activeCtx,activeProperty=null,element,options={}})=>{if(_isArray(element)){let rval=[];for(let i=0;i<element.length;++i){const compacted=await api.compact({activeCtx,activeProperty,element:element[i],options});null!==compacted&&rval.push(compacted)}if(options.compactArrays&&1===rval.length){0===(_getContextValue(activeCtx,activeProperty,"@container")||[]).length&&(rval=rval[0])}return rval}const ctx=_getContextValue(activeCtx,activeProperty,"@context");if(_isUndefined(ctx)||(activeCtx=await _processContext({activeCtx,localCtx:ctx,propagate:!0,overrideProtected:!0,options})),_isObject(element)){if(options.link&&"@id"in element&&options.link.hasOwnProperty(element["@id"])){const linked=options.link[element["@id"]];for(let i=0;i<linked.length;++i)if(linked[i].expanded===element)return linked[i].compacted}if(_isValue(element)||_isSubjectReference(element)){const rval=api.compactValue({activeCtx,activeProperty,value:element,options});return options.link&&_isSubjectReference(element)&&(options.link.hasOwnProperty(element["@id"])||(options.link[element["@id"]]=[]),options.link[element["@id"]].push({expanded:element,compacted:rval})),rval}if(_isList(element)){if((_getContextValue(activeCtx,activeProperty,"@container")||[]).includes("@list"))return api.compact({activeCtx,activeProperty,element:element["@list"],options})}const insideReverse="@reverse"===activeProperty,rval={},inputCtx=activeCtx;_isValue(element)||_isSubjectReference(element)||(activeCtx=activeCtx.revertToPreviousContext());const propertyScopedCtx=_getContextValue(inputCtx,activeProperty,"@context");_isUndefined(propertyScopedCtx)||(activeCtx=await _processContext({activeCtx,localCtx:propertyScopedCtx,propagate:!0,overrideProtected:!0,options})),options.link&&"@id"in element&&(options.link.hasOwnProperty(element["@id"])||(options.link[element["@id"]]=[]),options.link[element["@id"]].push({expanded:element,compacted:rval}));let types=element["@type"]||[];types.length>1&&(types=Array.from(types).sort());const typeContext=activeCtx;for(const type of types){const compactedType=api.compactIri({activeCtx:typeContext,iri:type,relativeTo:{vocab:!0}}),ctx=_getContextValue(inputCtx,compactedType,"@context");_isUndefined(ctx)||(activeCtx=await _processContext({activeCtx,localCtx:ctx,options,propagate:!1}))}const keys=Object.keys(element).sort();for(const expandedProperty of keys){const expandedValue=element[expandedProperty];if("@id"!==expandedProperty)if("@type"!==expandedProperty)if("@reverse"!==expandedProperty)if("@preserve"!==expandedProperty)if("@index"!==expandedProperty)if("@graph"!==expandedProperty&&"@list"!==expandedProperty&&"@included"!==expandedProperty&&_isKeyword(expandedProperty)){const alias=api.compactIri({activeCtx,iri:expandedProperty,relativeTo:{vocab:!0}});_addValue(rval,alias,expandedValue)}else{if(!_isArray(expandedValue))throw new JsonLdError("JSON-LD expansion error; expanded value must be an array.","jsonld.SyntaxError");if(0===expandedValue.length){const itemActiveProperty=api.compactIri({activeCtx,iri:expandedProperty,value:expandedValue,relativeTo:{vocab:!0},reverse:insideReverse}),nestProperty=activeCtx.mappings.has(itemActiveProperty)?activeCtx.mappings.get(itemActiveProperty)["@nest"]:null;let nestResult=rval;nestProperty&&(_checkNestProperty(activeCtx,nestProperty,options),_isObject(rval[nestProperty])||(rval[nestProperty]={}),nestResult=rval[nestProperty]),_addValue(nestResult,itemActiveProperty,expandedValue,{propertyIsArray:!0})}for(const expandedItem of expandedValue){const itemActiveProperty=api.compactIri({activeCtx,iri:expandedProperty,value:expandedItem,relativeTo:{vocab:!0},reverse:insideReverse}),nestProperty=activeCtx.mappings.has(itemActiveProperty)?activeCtx.mappings.get(itemActiveProperty)["@nest"]:null;let nestResult=rval;nestProperty&&(_checkNestProperty(activeCtx,nestProperty,options),_isObject(rval[nestProperty])||(rval[nestProperty]={}),nestResult=rval[nestProperty]);const container=_getContextValue(activeCtx,itemActiveProperty,"@container")||[],isGraph=_isGraph(expandedItem),isList=_isList(expandedItem);let inner;isList?inner=expandedItem["@list"]:isGraph&&(inner=expandedItem["@graph"]);let compactedItem=await api.compact({activeCtx,activeProperty:itemActiveProperty,element:isList||isGraph?inner:expandedItem,options});if(isList){if(_isArray(compactedItem)||(compactedItem=[compactedItem]),container.includes("@list")){_addValue(nestResult,itemActiveProperty,compactedItem,{valueIsArray:!0,allowDuplicate:!0});continue}compactedItem={[api.compactIri({activeCtx,iri:"@list",relativeTo:{vocab:!0}})]:compactedItem},"@index"in expandedItem&&(compactedItem[api.compactIri({activeCtx,iri:"@index",relativeTo:{vocab:!0}})]=expandedItem["@index"])}if(isGraph)if(container.includes("@graph")&&(container.includes("@id")||container.includes("@index")&&_isSimpleGraph(expandedItem))){let mapObject;nestResult.hasOwnProperty(itemActiveProperty)?mapObject=nestResult[itemActiveProperty]:nestResult[itemActiveProperty]=mapObject={};const key=(container.includes("@id")?expandedItem["@id"]:expandedItem["@index"])||api.compactIri({activeCtx,iri:"@none",relativeTo:{vocab:!0}});_addValue(mapObject,key,compactedItem,{propertyIsArray:!options.compactArrays||container.includes("@set")})}else container.includes("@graph")&&_isSimpleGraph(expandedItem)?(_isArray(compactedItem)&&compactedItem.length>1&&(compactedItem={"@included":compactedItem}),_addValue(nestResult,itemActiveProperty,compactedItem,{propertyIsArray:!options.compactArrays||container.includes("@set")})):(_isArray(compactedItem)&&1===compactedItem.length&&options.compactArrays&&(compactedItem=compactedItem[0]),compactedItem={[api.compactIri({activeCtx,iri:"@graph",relativeTo:{vocab:!0}})]:compactedItem},"@id"in expandedItem&&(compactedItem[api.compactIri({activeCtx,iri:"@id",relativeTo:{vocab:!0}})]=expandedItem["@id"]),"@index"in expandedItem&&(compactedItem[api.compactIri({activeCtx,iri:"@index",relativeTo:{vocab:!0}})]=expandedItem["@index"]),_addValue(nestResult,itemActiveProperty,compactedItem,{propertyIsArray:!options.compactArrays||container.includes("@set")}));else if(container.includes("@language")||container.includes("@index")||container.includes("@id")||container.includes("@type")){let mapObject,key;if(nestResult.hasOwnProperty(itemActiveProperty)?mapObject=nestResult[itemActiveProperty]:nestResult[itemActiveProperty]=mapObject={},container.includes("@language"))_isValue(compactedItem)&&(compactedItem=compactedItem["@value"]),key=expandedItem["@language"];else if(container.includes("@index")){const indexKey=_getContextValue(activeCtx,itemActiveProperty,"@index")||"@index",containerKey=api.compactIri({activeCtx,iri:indexKey,relativeTo:{vocab:!0}});if("@index"===indexKey)key=expandedItem["@index"],delete compactedItem[containerKey];else{let others;if([key,...others]=_asArray(compactedItem[indexKey]||[]),_isString(key))switch(others.length){case 0:delete compactedItem[indexKey];break;case 1:compactedItem[indexKey]=others[0];break;default:compactedItem[indexKey]=others}else key=null}}else if(container.includes("@id")){const idKey=api.compactIri({activeCtx,iri:"@id",relativeTo:{vocab:!0}});key=compactedItem[idKey],delete compactedItem[idKey]}else if(container.includes("@type")){const typeKey=api.compactIri({activeCtx,iri:"@type",relativeTo:{vocab:!0}});let types;switch([key,...types]=_asArray(compactedItem[typeKey]||[]),types.length){case 0:delete compactedItem[typeKey];break;case 1:compactedItem[typeKey]=types[0];break;default:compactedItem[typeKey]=types}1===Object.keys(compactedItem).length&&"@id"in expandedItem&&(compactedItem=await api.compact({activeCtx,activeProperty:itemActiveProperty,element:{"@id":expandedItem["@id"]},options}))}key||(key=api.compactIri({activeCtx,iri:"@none",relativeTo:{vocab:!0}})),_addValue(mapObject,key,compactedItem,{propertyIsArray:container.includes("@set")})}else{const isArray=!options.compactArrays||container.includes("@set")||container.includes("@list")||_isArray(compactedItem)&&0===compactedItem.length||"@list"===expandedProperty||"@graph"===expandedProperty;_addValue(nestResult,itemActiveProperty,compactedItem,{propertyIsArray:isArray})}}}else{if((_getContextValue(activeCtx,activeProperty,"@container")||[]).includes("@index"))continue;const alias=api.compactIri({activeCtx,iri:expandedProperty,relativeTo:{vocab:!0}});_addValue(rval,alias,expandedValue)}else{const compactedValue=await api.compact({activeCtx,activeProperty,element:expandedValue,options});_isArray(compactedValue)&&0===compactedValue.length||_addValue(rval,expandedProperty,compactedValue)}else{const compactedValue=await api.compact({activeCtx,activeProperty:"@reverse",element:expandedValue,options});for(const compactedProperty in compactedValue)if(activeCtx.mappings.has(compactedProperty)&&activeCtx.mappings.get(compactedProperty).reverse){const value=compactedValue[compactedProperty],useArray=(_getContextValue(activeCtx,compactedProperty,"@container")||[]).includes("@set")||!options.compactArrays;_addValue(rval,compactedProperty,value,{propertyIsArray:useArray}),delete compactedValue[compactedProperty]}if(Object.keys(compactedValue).length>0){const alias=api.compactIri({activeCtx,iri:expandedProperty,relativeTo:{vocab:!0}});_addValue(rval,alias,compactedValue)}}else{let compactedValue=_asArray(expandedValue).map((expandedIri=>api.compactIri({activeCtx:inputCtx,iri:expandedIri,relativeTo:{vocab:!0}})));1===compactedValue.length&&(compactedValue=compactedValue[0]);const alias=api.compactIri({activeCtx,iri:"@type",relativeTo:{vocab:!0}}),isArray=(_getContextValue(activeCtx,alias,"@container")||[]).includes("@set")&&_processingMode(activeCtx,1.1)||_isArray(compactedValue)&&0===expandedValue.length;_addValue(rval,alias,compactedValue,{propertyIsArray:isArray})}else{let compactedValue=_asArray(expandedValue).map((expandedIri=>api.compactIri({activeCtx,iri:expandedIri,relativeTo:{vocab:!1},base:options.base})));1===compactedValue.length&&(compactedValue=compactedValue[0]);rval[api.compactIri({activeCtx,iri:"@id",relativeTo:{vocab:!0}})]=compactedValue}}return rval}return element},api.compactIri=({activeCtx,iri,value=null,relativeTo={vocab:!1},reverse=!1,base=null})=>{if(null===iri)return iri;activeCtx.isPropertyTermScoped&&activeCtx.previousContext&&(activeCtx=activeCtx.previousContext);const inverseCtx=activeCtx.getInverse();if(_isKeyword(iri)&&iri in inverseCtx&&"@none"in inverseCtx[iri]&&"@type"in inverseCtx[iri]["@none"]&&"@none"in inverseCtx[iri]["@none"]["@type"])return inverseCtx[iri]["@none"]["@type"]["@none"];if(relativeTo.vocab&&iri in inverseCtx){const defaultLanguage=activeCtx["@language"]||"@none",containers=[];_isObject(value)&&"@index"in value&&!("@graph"in value)&&containers.push("@index","@index@set"),_isObject(value)&&"@preserve"in value&&(value=value["@preserve"][0]),_isGraph(value)?("@index"in value&&containers.push("@graph@index","@graph@index@set","@index","@index@set"),"@id"in value&&containers.push("@graph@id","@graph@id@set"),containers.push("@graph","@graph@set","@set"),"@index"in value||containers.push("@graph@index","@graph@index@set","@index","@index@set"),"@id"in value||containers.push("@graph@id","@graph@id@set")):_isObject(value)&&!_isValue(value)&&containers.push("@id","@id@set","@type","@set@type");let typeOrLanguage="@language",typeOrLanguageValue="@null";if(reverse)typeOrLanguage="@type",typeOrLanguageValue="@reverse",containers.push("@set");else if(_isList(value)){"@index"in value||containers.push("@list");const list=value["@list"];if(0===list.length)typeOrLanguage="@any",typeOrLanguageValue="@none";else{let commonLanguage=0===list.length?defaultLanguage:null,commonType=null;for(let i=0;i<list.length;++i){const item=list[i];let itemLanguage="@none",itemType="@none";if(_isValue(item))if("@direction"in item){itemLanguage=`${(item["@language"]||"").toLowerCase()}_${item["@direction"]}`}else"@language"in item?itemLanguage=item["@language"].toLowerCase():"@type"in item?itemType=item["@type"]:itemLanguage="@null";else itemType="@id";if(null===commonLanguage?commonLanguage=itemLanguage:itemLanguage!==commonLanguage&&_isValue(item)&&(commonLanguage="@none"),null===commonType?commonType=itemType:itemType!==commonType&&(commonType="@none"),"@none"===commonLanguage&&"@none"===commonType)break}commonLanguage=commonLanguage||"@none",commonType=commonType||"@none","@none"!==commonType?(typeOrLanguage="@type",typeOrLanguageValue=commonType):typeOrLanguageValue=commonLanguage}}else{if(_isValue(value))if("@language"in value&&!("@index"in value)){containers.push("@language","@language@set"),typeOrLanguageValue=value["@language"];const dir=value["@direction"];dir&&(typeOrLanguageValue=`${typeOrLanguageValue}_${dir}`)}else"@direction"in value&&!("@index"in value)?typeOrLanguageValue=`_${value["@direction"]}`:"@type"in value&&(typeOrLanguage="@type",typeOrLanguageValue=value["@type"]);else typeOrLanguage="@type",typeOrLanguageValue="@id";containers.push("@set")}containers.push("@none"),_isObject(value)&&!("@index"in value)&&containers.push("@index","@index@set"),_isValue(value)&&1===Object.keys(value).length&&containers.push("@language","@language@set");const term=function _selectTerm(activeCtx,iri,value,containers,typeOrLanguage,typeOrLanguageValue){null===typeOrLanguageValue&&(typeOrLanguageValue="@null");const prefs=[];if(("@id"===typeOrLanguageValue||"@reverse"===typeOrLanguageValue)&&_isObject(value)&&"@id"in value){"@reverse"===typeOrLanguageValue&&prefs.push("@reverse");const term=api.compactIri({activeCtx,iri:value["@id"],relativeTo:{vocab:!0}});activeCtx.mappings.has(term)&&activeCtx.mappings.get(term)&&activeCtx.mappings.get(term)["@id"]===value["@id"]?prefs.push.apply(prefs,["@vocab","@id"]):prefs.push.apply(prefs,["@id","@vocab"])}else{prefs.push(typeOrLanguageValue);const langDir=prefs.find((el=>el.includes("_")));langDir&&prefs.push(langDir.replace(/^[^_]+_/,"_"))}prefs.push("@none");const containerMap=activeCtx.inverse[iri];for(const container of containers){if(!(container in containerMap))continue;const typeOrLanguageValueMap=containerMap[container][typeOrLanguage];for(const pref of prefs)if(pref in typeOrLanguageValueMap)return typeOrLanguageValueMap[pref]}return null}(activeCtx,iri,value,containers,typeOrLanguage,typeOrLanguageValue);if(null!==term)return term}if(relativeTo.vocab&&"@vocab"in activeCtx){const vocab=activeCtx["@vocab"];if(0===iri.indexOf(vocab)&&iri!==vocab){const suffix=iri.substr(vocab.length);if(!activeCtx.mappings.has(suffix))return suffix}}let choice=null;const partialMatches=[];let iriMap=activeCtx.fastCurieMap;const maxPartialLength=iri.length-1;for(let i=0;i<maxPartialLength&&iri[i]in iriMap;++i)iriMap=iriMap[iri[i]],""in iriMap&&partialMatches.push(iriMap[""][0]);for(let i=partialMatches.length-1;i>=0;--i){const entry=partialMatches[i],terms=entry.terms;for(const term of terms){const curie=term+":"+iri.substr(entry.iri.length);activeCtx.mappings.get(term)._prefix&&(!activeCtx.mappings.has(curie)||null===value&&activeCtx.mappings.get(curie)["@id"]===iri)&&(null===choice||_compareShortestLeast(curie,choice)<0)&&(choice=curie)}}if(null!==choice)return choice;for(const[term,td]of activeCtx.mappings)if(td&&td._prefix&&iri.startsWith(term+":"))throw new JsonLdError(`Absolute IRI "${iri}" confused with prefix "${term}".`,"jsonld.SyntaxError",{code:"IRI confused with prefix",context:activeCtx});if(!relativeTo.vocab){if("@base"in activeCtx){if(activeCtx["@base"]){const _iri=_removeBase(_prependBase(base,activeCtx["@base"]),iri);return REGEX_KEYWORD.test(_iri)?`./${_iri}`:_iri}return iri}return _removeBase(base,iri)}return iri},api.compactValue=({activeCtx,activeProperty,value,options})=>{if(_isValue(value)){const type=_getContextValue(activeCtx,activeProperty,"@type"),language=_getContextValue(activeCtx,activeProperty,"@language"),direction=_getContextValue(activeCtx,activeProperty,"@direction"),container=_getContextValue(activeCtx,activeProperty,"@container")||[],preserveIndex="@index"in value&&!container.includes("@index");if(!preserveIndex&&"@none"!==type){if(value["@type"]===type)return value["@value"];if("@language"in value&&value["@language"]===language&&"@direction"in value&&value["@direction"]===direction)return value["@value"];if("@language"in value&&value["@language"]===language)return value["@value"];if("@direction"in value&&value["@direction"]===direction)return value["@value"]}const keyCount=Object.keys(value).length,isValueOnlyKey=1===keyCount||2===keyCount&&"@index"in value&&!preserveIndex,hasDefaultLanguage="@language"in activeCtx,isValueString=_isString(value["@value"]),hasNullMapping=activeCtx.mappings.has(activeProperty)&&null===activeCtx.mappings.get(activeProperty)["@language"];if(isValueOnlyKey&&"@none"!==type&&(!hasDefaultLanguage||!isValueString||hasNullMapping))return value["@value"];const rval={};return preserveIndex&&(rval[api.compactIri({activeCtx,iri:"@index",relativeTo:{vocab:!0}})]=value["@index"]),"@type"in value?rval[api.compactIri({activeCtx,iri:"@type",relativeTo:{vocab:!0}})]=api.compactIri({activeCtx,iri:value["@type"],relativeTo:{vocab:!0}}):"@language"in value&&(rval[api.compactIri({activeCtx,iri:"@language",relativeTo:{vocab:!0}})]=value["@language"]),"@direction"in value&&(rval[api.compactIri({activeCtx,iri:"@direction",relativeTo:{vocab:!0}})]=value["@direction"]),rval[api.compactIri({activeCtx,iri:"@value",relativeTo:{vocab:!0}})]=value["@value"],rval}const expandedProperty=_expandIri(activeCtx,activeProperty,{vocab:!0},options),type=_getContextValue(activeCtx,activeProperty,"@type"),compacted=api.compactIri({activeCtx,iri:value["@id"],relativeTo:{vocab:"@vocab"===type},base:options.base});return"@id"===type||"@vocab"===type||"@graph"===expandedProperty?compacted:{[api.compactIri({activeCtx,iri:"@id",relativeTo:{vocab:!0}})]:compacted}}},"./node_modules/jsonld/lib/constants.js":module=>{"use strict";const RDF="http://www.w3.org/1999/02/22-rdf-syntax-ns#",XSD="http://www.w3.org/2001/XMLSchema#";module.exports={LINK_HEADER_REL:"http://www.w3.org/ns/json-ld#context",LINK_HEADER_CONTEXT:"http://www.w3.org/ns/json-ld#context",RDF,RDF_LIST:RDF+"List",RDF_FIRST:RDF+"first",RDF_REST:RDF+"rest",RDF_NIL:RDF+"nil",RDF_TYPE:RDF+"type",RDF_PLAIN_LITERAL:RDF+"PlainLiteral",RDF_XML_LITERAL:RDF+"XMLLiteral",RDF_JSON_LITERAL:RDF+"JSON",RDF_OBJECT:RDF+"object",RDF_LANGSTRING:RDF+"langString",XSD,XSD_BOOLEAN:XSD+"boolean",XSD_DOUBLE:XSD+"double",XSD_INTEGER:XSD+"integer",XSD_STRING:XSD+"string"}},"./node_modules/jsonld/lib/context.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";const util=__webpack_require__("./node_modules/jsonld/lib/util.js"),JsonLdError=__webpack_require__("./node_modules/jsonld/lib/JsonLdError.js"),{isArray:_isArray,isObject:_isObject,isString:_isString,isUndefined:_isUndefined}=__webpack_require__("./node_modules/jsonld/lib/types.js"),{isAbsolute:_isAbsoluteIri,isRelative:_isRelativeIri,prependBase}=__webpack_require__("./node_modules/jsonld/lib/url.js"),{handleEvent:_handleEvent}=__webpack_require__("./node_modules/jsonld/lib/events.js"),{REGEX_BCP47,REGEX_KEYWORD,asArray:_asArray,compareShortestLeast:_compareShortestLeast}=__webpack_require__("./node_modules/jsonld/lib/util.js"),INITIAL_CONTEXT_CACHE=new Map,api={};function _expandIri(activeCtx,value,relativeTo,localCtx,defined,options){if(null===value||!_isString(value)||api.isKeyword(value))return value;if(value.match(REGEX_KEYWORD))return null;if(localCtx&&localCtx.hasOwnProperty(value)&&!0!==defined.get(value)&&api.createTermDefinition({activeCtx,localCtx,term:value,defined,options}),(relativeTo=relativeTo||{}).vocab){const mapping=activeCtx.mappings.get(value);if(null===mapping)return null;if(_isObject(mapping)&&"@id"in mapping)return mapping["@id"]}const colon=value.indexOf(":");if(colon>0){const prefix=value.substr(0,colon),suffix=value.substr(colon+1);if("_"===prefix||0===suffix.indexOf("//"))return value;localCtx&&localCtx.hasOwnProperty(prefix)&&api.createTermDefinition({activeCtx,localCtx,term:prefix,defined,options});const mapping=activeCtx.mappings.get(prefix);if(mapping&&mapping._prefix)return mapping["@id"]+suffix;if(_isAbsoluteIri(value))return value}if(relativeTo.vocab&&"@vocab"in activeCtx){value=activeCtx["@vocab"]+value}else if(relativeTo.base){let prependedResult,base;"@base"in activeCtx?activeCtx["@base"]?(base=prependBase(options.base,activeCtx["@base"]),prependedResult=prependBase(base,value)):(base=activeCtx["@base"],prependedResult=value):(base=options.base,prependedResult=prependBase(options.base,value)),value=prependedResult}return value}function _deepCompare(x1,x2){if(!x1||"object"!=typeof x1||!x2||"object"!=typeof x2)return x1===x2;const x1Array=Array.isArray(x1);if(x1Array!==Array.isArray(x2))return!1;if(x1Array){if(x1.length!==x2.length)return!1;for(let i=0;i<x1.length;++i)if(!_deepCompare(x1[i],x2[i]))return!1;return!0}const k1s=Object.keys(x1),k2s=Object.keys(x2);if(k1s.length!==k2s.length)return!1;for(const k1 in x1){let v1=x1[k1],v2=x2[k1];if("@container"===k1&&Array.isArray(v1)&&Array.isArray(v2)&&(v1=v1.slice().sort(),v2=v2.slice().sort()),!_deepCompare(v1,v2))return!1}return!0}module.exports=api,api.process=async({activeCtx,localCtx,options,propagate=!0,overrideProtected=!1,cycles=new Set})=>{_isObject(localCtx)&&"@context"in localCtx&&_isArray(localCtx["@context"])&&(localCtx=localCtx["@context"]);if(0===_asArray(localCtx).length)return activeCtx;const events=[],eventCaptureHandler=[({event,next})=>{events.push(event),next()}];options.eventHandler&&eventCaptureHandler.push(options.eventHandler);const originalOptions=options;options={...options,eventHandler:eventCaptureHandler};const resolved=await options.contextResolver.resolve({activeCtx,context:localCtx,documentLoader:options.documentLoader,base:options.base});_isObject(resolved[0].document)&&"boolean"==typeof resolved[0].document["@propagate"]&&(propagate=resolved[0].document["@propagate"]);let rval=activeCtx;propagate||rval.previousContext||(rval=rval.clone(),rval.previousContext=activeCtx);for(const resolvedContext of resolved){let{document:ctx}=resolvedContext;if(activeCtx=rval,null===ctx){if(!overrideProtected&&0!==Object.keys(activeCtx.protected).length)throw new JsonLdError("Tried to nullify a context with protected terms outside of a term definition.","jsonld.SyntaxError",{code:"invalid context nullification"});rval=activeCtx=api.getInitialContext(options).clone();continue}const processed=resolvedContext.getProcessed(activeCtx);if(processed){if(originalOptions.eventHandler)for(const event of processed.events)_handleEvent({event,options:originalOptions});rval=activeCtx=processed.context;continue}if(_isObject(ctx)&&"@context"in ctx&&(ctx=ctx["@context"]),!_isObject(ctx))throw new JsonLdError("Invalid JSON-LD syntax; @context must be an object.","jsonld.SyntaxError",{code:"invalid local context",context:ctx});rval=rval.clone();const defined=new Map;if("@version"in ctx){if(1.1!==ctx["@version"])throw new JsonLdError("Unsupported JSON-LD version: "+ctx["@version"],"jsonld.UnsupportedVersion",{code:"invalid @version value",context:ctx});if(activeCtx.processingMode&&"json-ld-1.0"===activeCtx.processingMode)throw new JsonLdError("@version: "+ctx["@version"]+" not compatible with "+activeCtx.processingMode,"jsonld.ProcessingModeConflict",{code:"processing mode conflict",context:ctx});rval.processingMode="json-ld-1.1",rval["@version"]=ctx["@version"],defined.set("@version",!0)}if(rval.processingMode=rval.processingMode||activeCtx.processingMode,"@base"in ctx){let base=ctx["@base"];if(null===base||_isAbsoluteIri(base));else{if(!_isRelativeIri(base))throw new JsonLdError('Invalid JSON-LD syntax; the value of "@base" in a @context must be an absolute IRI, a relative IRI, or null.',"jsonld.SyntaxError",{code:"invalid base IRI",context:ctx});base=prependBase(rval["@base"],base)}rval["@base"]=base,defined.set("@base",!0)}if("@vocab"in ctx){const value=ctx["@vocab"];if(null===value)delete rval["@vocab"];else{if(!_isString(value))throw new JsonLdError('Invalid JSON-LD syntax; the value of "@vocab" in a @context must be a string or null.',"jsonld.SyntaxError",{code:"invalid vocab mapping",context:ctx});if(!_isAbsoluteIri(value)&&api.processingMode(rval,1))throw new JsonLdError('Invalid JSON-LD syntax; the value of "@vocab" in a @context must be an absolute IRI.',"jsonld.SyntaxError",{code:"invalid vocab mapping",context:ctx});{const vocab=_expandIri(rval,value,{vocab:!0,base:!0},void 0,void 0,options);_isAbsoluteIri(vocab)||options.eventHandler&&_handleEvent({event:{type:["JsonLdEvent"],code:"relative @vocab reference",level:"warning",message:"Relative @vocab reference found.",details:{vocab}},options}),rval["@vocab"]=vocab}}defined.set("@vocab",!0)}if("@language"in ctx){const value=ctx["@language"];if(null===value)delete rval["@language"];else{if(!_isString(value))throw new JsonLdError('Invalid JSON-LD syntax; the value of "@language" in a @context must be a string or null.',"jsonld.SyntaxError",{code:"invalid default language",context:ctx});value.match(REGEX_BCP47)||options.eventHandler&&_handleEvent({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:value}},options}),rval["@language"]=value.toLowerCase()}defined.set("@language",!0)}if("@direction"in ctx){const value=ctx["@direction"];if("json-ld-1.0"===activeCtx.processingMode)throw new JsonLdError("Invalid JSON-LD syntax; @direction not compatible with "+activeCtx.processingMode,"jsonld.SyntaxError",{code:"invalid context member",context:ctx});if(null===value)delete rval["@direction"];else{if("ltr"!==value&&"rtl"!==value)throw new JsonLdError('Invalid JSON-LD syntax; the value of "@direction" in a @context must be null, "ltr", or "rtl".',"jsonld.SyntaxError",{code:"invalid base direction",context:ctx});rval["@direction"]=value}defined.set("@direction",!0)}if("@propagate"in ctx){const value=ctx["@propagate"];if("json-ld-1.0"===activeCtx.processingMode)throw new JsonLdError("Invalid JSON-LD syntax; @propagate not compatible with "+activeCtx.processingMode,"jsonld.SyntaxError",{code:"invalid context entry",context:ctx});if("boolean"!=typeof value)throw new JsonLdError("Invalid JSON-LD syntax; @propagate value must be a boolean.","jsonld.SyntaxError",{code:"invalid @propagate value",context:localCtx});defined.set("@propagate",!0)}if("@import"in ctx){const value=ctx["@import"];if("json-ld-1.0"===activeCtx.processingMode)throw new JsonLdError("Invalid JSON-LD syntax; @import not compatible with "+activeCtx.processingMode,"jsonld.SyntaxError",{code:"invalid context entry",context:ctx});if(!_isString(value))throw new JsonLdError("Invalid JSON-LD syntax; @import must be a string.","jsonld.SyntaxError",{code:"invalid @import value",context:localCtx});const resolvedImport=await options.contextResolver.resolve({activeCtx,context:value,documentLoader:options.documentLoader,base:options.base});if(1!==resolvedImport.length)throw new JsonLdError("Invalid JSON-LD syntax; @import must reference a single context.","jsonld.SyntaxError",{code:"invalid remote context",context:localCtx});const processedImport=resolvedImport[0].getProcessed(activeCtx);if(processedImport)ctx=processedImport;else{const importCtx=resolvedImport[0].document;if("@import"in importCtx)throw new JsonLdError("Invalid JSON-LD syntax: imported context must not include @import.","jsonld.SyntaxError",{code:"invalid context entry",context:localCtx});for(const key in importCtx)ctx.hasOwnProperty(key)||(ctx[key]=importCtx[key]);resolvedImport[0].setProcessed(activeCtx,ctx)}defined.set("@import",!0)}defined.set("@protected",ctx["@protected"]||!1);for(const key in ctx)if(api.createTermDefinition({activeCtx:rval,localCtx:ctx,term:key,defined,options,overrideProtected}),_isObject(ctx[key])&&"@context"in ctx[key]){const keyCtx=ctx[key]["@context"];let process=!0;if(_isString(keyCtx)){const url=prependBase(options.base,keyCtx);cycles.has(url)?process=!1:cycles.add(url)}if(process)try{await api.process({activeCtx:rval.clone(),localCtx:ctx[key]["@context"],overrideProtected:!0,options,cycles})}catch(e){throw new JsonLdError("Invalid JSON-LD syntax; invalid scoped context.","jsonld.SyntaxError",{code:"invalid scoped context",context:ctx[key]["@context"],term:key})}}resolvedContext.setProcessed(activeCtx,{context:rval,events})}return rval},api.createTermDefinition=({activeCtx,localCtx,term,defined,options,overrideProtected=!1})=>{if(defined.has(term)){if(defined.get(term))return;throw new JsonLdError("Cyclical context definition detected.","jsonld.CyclicalContext",{code:"cyclic IRI mapping",context:localCtx,term})}let value;if(defined.set(term,!1),localCtx.hasOwnProperty(term)&&(value=localCtx[term]),"@type"===term&&_isObject(value)&&"@set"===(value["@container"]||"@set")&&api.processingMode(activeCtx,1.1)){const validKeys=["@container","@id","@protected"],keys=Object.keys(value);if(0===keys.length||keys.some((k=>!validKeys.includes(k))))throw new JsonLdError("Invalid JSON-LD syntax; keywords cannot be overridden.","jsonld.SyntaxError",{code:"keyword redefinition",context:localCtx,term})}else{if(api.isKeyword(term))throw new JsonLdError("Invalid JSON-LD syntax; keywords cannot be overridden.","jsonld.SyntaxError",{code:"keyword redefinition",context:localCtx,term});if(term.match(REGEX_KEYWORD))return void(options.eventHandler&&_handleEvent({event:{type:["JsonLdEvent"],code:"reserved term",level:"warning",message:'Terms beginning with "@" are reserved for future use and dropped.',details:{term}},options}));if(""===term)throw new JsonLdError("Invalid JSON-LD syntax; a term cannot be an empty string.","jsonld.SyntaxError",{code:"invalid term definition",context:localCtx})}const previousMapping=activeCtx.mappings.get(term);activeCtx.mappings.has(term)&&activeCtx.mappings.delete(term);let simpleTerm=!1;if((_isString(value)||null===value)&&(simpleTerm=!0,value={"@id":value}),!_isObject(value))throw new JsonLdError("Invalid JSON-LD syntax; @context term values must be strings or objects.","jsonld.SyntaxError",{code:"invalid term definition",context:localCtx});const mapping={};activeCtx.mappings.set(term,mapping),mapping.reverse=!1;const validKeys=["@container","@id","@language","@reverse","@type"];api.processingMode(activeCtx,1.1)&&validKeys.push("@context","@direction","@index","@nest","@prefix","@protected");for(const kw in value)if(!validKeys.includes(kw))throw new JsonLdError("Invalid JSON-LD syntax; a term definition must not contain "+kw,"jsonld.SyntaxError",{code:"invalid term definition",context:localCtx});const colon=term.indexOf(":");if(mapping._termHasColon=colon>0,"@reverse"in value){if("@id"in value)throw new JsonLdError("Invalid JSON-LD syntax; a @reverse term definition must not contain @id.","jsonld.SyntaxError",{code:"invalid reverse property",context:localCtx});if("@nest"in value)throw new JsonLdError("Invalid JSON-LD syntax; a @reverse term definition must not contain @nest.","jsonld.SyntaxError",{code:"invalid reverse property",context:localCtx});const reverse=value["@reverse"];if(!_isString(reverse))throw new JsonLdError("Invalid JSON-LD syntax; a @context @reverse value must be a string.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:localCtx});if(reverse.match(REGEX_KEYWORD))return options.eventHandler&&_handleEvent({event:{type:["JsonLdEvent"],code:"reserved @reverse value",level:"warning",message:'@reverse values beginning with "@" are reserved for future use and dropped.',details:{reverse}},options}),void(previousMapping?activeCtx.mappings.set(term,previousMapping):activeCtx.mappings.delete(term));const id=_expandIri(activeCtx,reverse,{vocab:!0,base:!1},localCtx,defined,options);if(!_isAbsoluteIri(id))throw new JsonLdError("Invalid JSON-LD syntax; a @context @reverse value must be an absolute IRI or a blank node identifier.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:localCtx});mapping["@id"]=id,mapping.reverse=!0}else if("@id"in value){let id=value["@id"];if(id&&!_isString(id))throw new JsonLdError("Invalid JSON-LD syntax; a @context @id value must be an array of strings or a string.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:localCtx});if(null===id)mapping["@id"]=null;else{if(!api.isKeyword(id)&&id.match(REGEX_KEYWORD))return options.eventHandler&&_handleEvent({event:{type:["JsonLdEvent"],code:"reserved @id value",level:"warning",message:'@id values beginning with "@" are reserved for future use and dropped.',details:{id}},options}),void(previousMapping?activeCtx.mappings.set(term,previousMapping):activeCtx.mappings.delete(term));if(id!==term){if(id=_expandIri(activeCtx,id,{vocab:!0,base:!1},localCtx,defined,options),!_isAbsoluteIri(id)&&!api.isKeyword(id))throw new JsonLdError("Invalid JSON-LD syntax; a @context @id value must be an absolute IRI, a blank node identifier, or a keyword.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:localCtx});if(term.match(/(?::[^:])|\//)){if(_expandIri(activeCtx,term,{vocab:!0,base:!1},localCtx,new Map(defined).set(term,!0),options)!==id)throw new JsonLdError("Invalid JSON-LD syntax; term in form of IRI must expand to definition.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:localCtx})}mapping["@id"]=id,mapping._prefix=simpleTerm&&!mapping._termHasColon&&null!==id.match(/[:\/\?#\[\]@]$/)}}}if(!("@id"in mapping))if(mapping._termHasColon){const prefix=term.substr(0,colon);if(localCtx.hasOwnProperty(prefix)&&api.createTermDefinition({activeCtx,localCtx,term:prefix,defined,options}),activeCtx.mappings.has(prefix)){const suffix=term.substr(colon+1);mapping["@id"]=activeCtx.mappings.get(prefix)["@id"]+suffix}else mapping["@id"]=term}else if("@type"===term)mapping["@id"]=term;else{if(!("@vocab"in activeCtx))throw new JsonLdError("Invalid JSON-LD syntax; @context terms must define an @id.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:localCtx,term});mapping["@id"]=activeCtx["@vocab"]+term}if((!0===value["@protected"]||!0===defined.get("@protected")&&!1!==value["@protected"])&&(activeCtx.protected[term]=!0,mapping.protected=!0),defined.set(term,!0),"@type"in value){let type=value["@type"];if(!_isString(type))throw new JsonLdError("Invalid JSON-LD syntax; an @context @type value must be a string.","jsonld.SyntaxError",{code:"invalid type mapping",context:localCtx});if("@json"===type||"@none"===type){if(api.processingMode(activeCtx,1))throw new JsonLdError(`Invalid JSON-LD syntax; an @context @type value must not be "${type}" in JSON-LD 1.0 mode.`,"jsonld.SyntaxError",{code:"invalid type mapping",context:localCtx})}else if("@id"!==type&&"@vocab"!==type){if(type=_expandIri(activeCtx,type,{vocab:!0,base:!1},localCtx,defined,options),!_isAbsoluteIri(type))throw new JsonLdError("Invalid JSON-LD syntax; an @context @type value must be an absolute IRI.","jsonld.SyntaxError",{code:"invalid type mapping",context:localCtx});if(0===type.indexOf("_:"))throw new JsonLdError("Invalid JSON-LD syntax; an @context @type value must be an IRI, not a blank node identifier.","jsonld.SyntaxError",{code:"invalid type mapping",context:localCtx})}mapping["@type"]=type}if("@container"in value){const container=_isString(value["@container"])?[value["@container"]]:value["@container"]||[],validContainers=["@list","@set","@index","@language"];let isValid=!0;const hasSet=container.includes("@set");if(api.processingMode(activeCtx,1.1)){if(validContainers.push("@graph","@id","@type"),container.includes("@list")){if(1!==container.length)throw new JsonLdError("Invalid JSON-LD syntax; @context @container with @list must have no other values","jsonld.SyntaxError",{code:"invalid container mapping",context:localCtx})}else if(container.includes("@graph")){if(container.some((key=>"@graph"!==key&&"@id"!==key&&"@index"!==key&&"@set"!==key)))throw new JsonLdError("Invalid JSON-LD syntax; @context @container with @graph must have no other values other than @id, @index, and @set","jsonld.SyntaxError",{code:"invalid container mapping",context:localCtx})}else isValid&=container.length<=(hasSet?2:1);if(container.includes("@type")&&(mapping["@type"]=mapping["@type"]||"@id",!["@id","@vocab"].includes(mapping["@type"])))throw new JsonLdError("Invalid JSON-LD syntax; container: @type requires @type to be @id or @vocab.","jsonld.SyntaxError",{code:"invalid type mapping",context:localCtx})}else isValid&=!_isArray(value["@container"]),isValid&=container.length<=1;if(isValid&=container.every((c=>validContainers.includes(c))),isValid&=!(hasSet&&container.includes("@list")),!isValid)throw new JsonLdError("Invalid JSON-LD syntax; @context @container value must be one of the following: "+validContainers.join(", "),"jsonld.SyntaxError",{code:"invalid container mapping",context:localCtx});if(mapping.reverse&&!container.every((c=>["@index","@set"].includes(c))))throw new JsonLdError("Invalid JSON-LD syntax; @context @container value for a @reverse type definition must be @index or @set.","jsonld.SyntaxError",{code:"invalid reverse property",context:localCtx});mapping["@container"]=container}if("@index"in value){if(!("@container"in value)||!mapping["@container"].includes("@index"))throw new JsonLdError(`Invalid JSON-LD syntax; @index without @index in @container: "${value["@index"]}" on term "${term}".`,"jsonld.SyntaxError",{code:"invalid term definition",context:localCtx});if(!_isString(value["@index"])||0===value["@index"].indexOf("@"))throw new JsonLdError(`Invalid JSON-LD syntax; @index must expand to an IRI: "${value["@index"]}" on term "${term}".`,"jsonld.SyntaxError",{code:"invalid term definition",context:localCtx});mapping["@index"]=value["@index"]}if("@context"in value&&(mapping["@context"]=value["@context"]),"@language"in value&&!("@type"in value)){let language=value["@language"];if(null!==language&&!_isString(language))throw new JsonLdError("Invalid JSON-LD syntax; @context @language value must be a string or null.","jsonld.SyntaxError",{code:"invalid language mapping",context:localCtx});null!==language&&(language=language.toLowerCase()),mapping["@language"]=language}if("@prefix"in value){if(term.match(/:|\//))throw new JsonLdError("Invalid JSON-LD syntax; @context @prefix used on a compact IRI term","jsonld.SyntaxError",{code:"invalid term definition",context:localCtx});if(api.isKeyword(mapping["@id"]))throw new JsonLdError("Invalid JSON-LD syntax; keywords may not be used as prefixes","jsonld.SyntaxError",{code:"invalid term definition",context:localCtx});if("boolean"!=typeof value["@prefix"])throw new JsonLdError("Invalid JSON-LD syntax; @context value for @prefix must be boolean","jsonld.SyntaxError",{code:"invalid @prefix value",context:localCtx});mapping._prefix=!0===value["@prefix"]}if("@direction"in value){const direction=value["@direction"];if(null!==direction&&"ltr"!==direction&&"rtl"!==direction)throw new JsonLdError('Invalid JSON-LD syntax; @direction value must be null, "ltr", or "rtl".',"jsonld.SyntaxError",{code:"invalid base direction",context:localCtx});mapping["@direction"]=direction}if("@nest"in value){const nest=value["@nest"];if(!_isString(nest)||"@nest"!==nest&&0===nest.indexOf("@"))throw new JsonLdError("Invalid JSON-LD syntax; @context @nest value must be a string which is not a keyword other than @nest.","jsonld.SyntaxError",{code:"invalid @nest value",context:localCtx});mapping["@nest"]=nest}const id=mapping["@id"];if("@context"===id||"@preserve"===id)throw new JsonLdError("Invalid JSON-LD syntax; @context and @preserve cannot be aliased.","jsonld.SyntaxError",{code:"invalid keyword alias",context:localCtx});if(previousMapping&&previousMapping.protected&&!overrideProtected&&(activeCtx.protected[term]=!0,mapping.protected=!0,!_deepCompare(previousMapping,mapping)))throw new JsonLdError("Invalid JSON-LD syntax; tried to redefine a protected term.","jsonld.SyntaxError",{code:"protected term redefinition",context:localCtx,term})},api.expandIri=(activeCtx,value,relativeTo,options)=>_expandIri(activeCtx,value,relativeTo,void 0,void 0,options),api.getInitialContext=options=>{const key=JSON.stringify({processingMode:options.processingMode}),cached=INITIAL_CONTEXT_CACHE.get(key);if(cached)return cached;const initialContext={processingMode:options.processingMode,mappings:new Map,inverse:null,getInverse:function _createInverseContext(){const activeCtx=this;if(activeCtx.inverse)return activeCtx.inverse;const inverse=activeCtx.inverse={},fastCurieMap=activeCtx.fastCurieMap={},irisToTerms={},defaultLanguage=(activeCtx["@language"]||"@none").toLowerCase(),defaultDirection=activeCtx["@direction"],mappings=activeCtx.mappings,terms=[...mappings.keys()].sort(_compareShortestLeast);for(const term of terms){const mapping=mappings.get(term);if(null===mapping)continue;let container=mapping["@container"]||"@none";if(container=[].concat(container).sort().join(""),null===mapping["@id"])continue;const ids=_asArray(mapping["@id"]);for(const iri of ids){let entry=inverse[iri];const isKeyword=api.isKeyword(iri);if(entry)isKeyword||mapping._termHasColon||irisToTerms[iri].push(term);else if(inverse[iri]=entry={},!isKeyword&&!mapping._termHasColon){irisToTerms[iri]=[term];const fastCurieEntry={iri,terms:irisToTerms[iri]};iri[0]in fastCurieMap?fastCurieMap[iri[0]].push(fastCurieEntry):fastCurieMap[iri[0]]=[fastCurieEntry]}if(entry[container]||(entry[container]={"@language":{},"@type":{},"@any":{}}),entry=entry[container],_addPreferredTerm(term,entry["@any"],"@none"),mapping.reverse)_addPreferredTerm(term,entry["@type"],"@reverse");else if("@none"===mapping["@type"])_addPreferredTerm(term,entry["@any"],"@none"),_addPreferredTerm(term,entry["@language"],"@none"),_addPreferredTerm(term,entry["@type"],"@none");else if("@type"in mapping)_addPreferredTerm(term,entry["@type"],mapping["@type"]);else if("@language"in mapping&&"@direction"in mapping){const language=mapping["@language"],direction=mapping["@direction"];_addPreferredTerm(term,entry["@language"],language&&direction?`${language}_${direction}`.toLowerCase():language?language.toLowerCase():direction?`_${direction}`:"@null")}else"@language"in mapping?_addPreferredTerm(term,entry["@language"],(mapping["@language"]||"@null").toLowerCase()):"@direction"in mapping?mapping["@direction"]?_addPreferredTerm(term,entry["@language"],`_${mapping["@direction"]}`):_addPreferredTerm(term,entry["@language"],"@none"):defaultDirection?(_addPreferredTerm(term,entry["@language"],`_${defaultDirection}`),_addPreferredTerm(term,entry["@language"],"@none"),_addPreferredTerm(term,entry["@type"],"@none")):(_addPreferredTerm(term,entry["@language"],defaultLanguage),_addPreferredTerm(term,entry["@language"],"@none"),_addPreferredTerm(term,entry["@type"],"@none"))}}for(const key in fastCurieMap)_buildIriMap(fastCurieMap,key,1);return inverse},clone:function _cloneActiveContext(){const child={};child.mappings=util.clone(this.mappings),child.clone=this.clone,child.inverse=null,child.getInverse=this.getInverse,child.protected=util.clone(this.protected),this.previousContext&&(child.previousContext=this.previousContext.clone());child.revertToPreviousContext=this.revertToPreviousContext,"@base"in this&&(child["@base"]=this["@base"]);"@language"in this&&(child["@language"]=this["@language"]);"@vocab"in this&&(child["@vocab"]=this["@vocab"]);return child},revertToPreviousContext:function _revertToPreviousContext(){if(!this.previousContext)return this;return this.previousContext.clone()},protected:{}};return 1e4===INITIAL_CONTEXT_CACHE.size&&INITIAL_CONTEXT_CACHE.clear(),INITIAL_CONTEXT_CACHE.set(key,initialContext),initialContext;function _buildIriMap(iriMap,key,idx){const entries=iriMap[key],next=iriMap[key]={};let iri,letter;for(const entry of entries)iri=entry.iri,letter=idx>=iri.length?"":iri[idx],letter in next?next[letter].push(entry):next[letter]=[entry];for(const key in next)""!==key&&_buildIriMap(next,key,idx+1)}function _addPreferredTerm(term,entry,typeOrLanguageValue){entry.hasOwnProperty(typeOrLanguageValue)||(entry[typeOrLanguageValue]=term)}},api.getContextValue=(ctx,key,type)=>{if(null===key){if("@context"===type)return;return null}if(ctx.mappings.has(key)){const entry=ctx.mappings.get(key);if(_isUndefined(type))return entry;if(entry.hasOwnProperty(type))return entry[type]}return"@language"===type&&type in ctx||"@direction"===type&&type in ctx?ctx[type]:"@context"!==type?null:void 0},api.processingMode=(activeCtx,version)=>version.toString()>="1.1"?!activeCtx.processingMode||activeCtx.processingMode>="json-ld-"+version.toString():"json-ld-1.0"===activeCtx.processingMode,api.isKeyword=v=>{if(!_isString(v)||"@"!==v[0])return!1;switch(v){case"@base":case"@container":case"@context":case"@default":case"@direction":case"@embed":case"@explicit":case"@graph":case"@id":case"@included":case"@index":case"@json":case"@language":case"@list":case"@nest":case"@none":case"@omitDefault":case"@prefix":case"@preserve":case"@protected":case"@requireAll":case"@reverse":case"@set":case"@type":case"@value":case"@version":case"@vocab":return!0}return!1}},"./node_modules/jsonld/lib/documentLoaders/xhr.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";const{parseLinkHeader,buildHeaders}=__webpack_require__("./node_modules/jsonld/lib/util.js"),{LINK_HEADER_CONTEXT}=__webpack_require__("./node_modules/jsonld/lib/constants.js"),JsonLdError=__webpack_require__("./node_modules/jsonld/lib/JsonLdError.js"),RequestQueue=__webpack_require__("./node_modules/jsonld/lib/RequestQueue.js"),{prependBase}=__webpack_require__("./node_modules/jsonld/lib/url.js"),REGEX_LINK_HEADER=/(^|(\r\n))link:/i;module.exports=({secure,headers={},xhr}={headers:{}})=>{headers=buildHeaders(headers);return(new RequestQueue).wrapLoader((async function loader(url){if(0!==url.indexOf("http:")&&0!==url.indexOf("https:"))throw new JsonLdError('URL could not be dereferenced; only "http" and "https" URLs are supported.',"jsonld.InvalidUrl",{code:"loading document failed",url});if(secure&&0!==url.indexOf("https"))throw new JsonLdError('URL could not be dereferenced; secure mode is enabled and the URL\'s scheme is not "https".',"jsonld.InvalidUrl",{code:"loading document failed",url});let req;try{req=await function _get(xhr,url,headers){xhr=xhr||XMLHttpRequest;const req=new xhr;return new Promise(((resolve,reject)=>{req.onload=()=>resolve(req),req.onerror=err=>reject(err),req.open("GET",url,!0);for(const k in headers)req.setRequestHeader(k,headers[k]);req.send()}))}(xhr,url,headers)}catch(e){throw new JsonLdError("URL could not be dereferenced, an error occurred.","jsonld.LoadDocumentError",{code:"loading document failed",url,cause:e})}if(req.status>=400)throw new JsonLdError("URL could not be dereferenced: "+req.statusText,"jsonld.LoadDocumentError",{code:"loading document failed",url,httpStatusCode:req.status});let doc={contextUrl:null,documentUrl:url,document:req.response},alternate=null;const contentType=req.getResponseHeader("Content-Type");let linkHeader;REGEX_LINK_HEADER.test(req.getAllResponseHeaders())&&(linkHeader=req.getResponseHeader("Link"));if(linkHeader&&"application/ld+json"!==contentType){const linkHeaders=parseLinkHeader(linkHeader),linkedContext=linkHeaders[LINK_HEADER_CONTEXT];if(Array.isArray(linkedContext))throw new JsonLdError("URL could not be dereferenced, it has more than one associated HTTP Link Header.","jsonld.InvalidUrl",{code:"multiple context link headers",url});linkedContext&&(doc.contextUrl=linkedContext.target),alternate=linkHeaders.alternate,alternate&&"application/ld+json"==alternate.type&&!(contentType||"").match(/^application\/(\w*\+)?json$/)&&(doc=await loader(prependBase(url,alternate.target)))}return doc}))}},"./node_modules/jsonld/lib/events.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";const JsonLdError=__webpack_require__("./node_modules/jsonld/lib/JsonLdError.js"),{isArray:_isArray}=__webpack_require__("./node_modules/jsonld/lib/types.js"),{asArray:_asArray}=__webpack_require__("./node_modules/jsonld/lib/util.js"),api={};function _handle({event,handlers}){let doNext=!0;for(let i=0;doNext&&i<handlers.length;++i){doNext=!1;const handler=handlers[i];if(_isArray(handler))doNext=_handle({event,handlers:handler});else if("function"==typeof handler)handler({event,next:()=>{doNext=!0}});else{if("object"!=typeof handler)throw new JsonLdError("Invalid event handler.","jsonld.InvalidEventHandler",{event});event.code in handler?handler[event.code]({event,next:()=>{doNext=!0}}):doNext=!0}}return doNext}module.exports=api,api.defaultEventHandler=null,api.setupEventHandler=({options={}})=>{const eventHandler=[].concat(options.safe?api.safeEventHandler:[],options.eventHandler?_asArray(options.eventHandler):[],api.defaultEventHandler?api.defaultEventHandler:[]);return 0===eventHandler.length?null:eventHandler},api.handleEvent=({event,options})=>{_handle({event,handlers:options.eventHandler})};const _notSafeEventCodes=new Set(["empty object","free-floating scalar","invalid @language value","invalid property","null @id value","null @value value","object with only @id","object with only @language","object with only @list","object with only @value","relative @id reference","relative @type reference","relative @vocab reference","reserved @id value","reserved @reverse value","reserved term","blank node predicate","relative graph reference","relative object reference","relative predicate reference","relative subject reference","rdfDirection not set"]);api.safeEventHandler=function safeEventHandler({event,next}){if("warning"===event.level&&_notSafeEventCodes.has(event.code))throw new JsonLdError("Safe mode validation error.","jsonld.ValidationError",{event});next()},api.logEventHandler=function logEventHandler({event,next}){console.log(`EVENT: ${event.message}`,{event}),next()},api.logWarningEventHandler=function logWarningEventHandler({event,next}){"warning"===event.level&&console.warn(`WARNING: ${event.message}`,{event}),next()},api.unhandledEventHandler=function unhandledEventHandler({event}){throw new JsonLdError("No handler for event.","jsonld.UnhandledEvent",{event})},api.setDefaultEventHandler=function({eventHandler}={}){api.defaultEventHandler=eventHandler?_asArray(eventHandler):null}},"./node_modules/jsonld/lib/expand.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";const JsonLdError=__webpack_require__("./node_modules/jsonld/lib/JsonLdError.js"),{isArray:_isArray,isObject:_isObject,isEmptyObject:_isEmptyObject,isString:_isString,isUndefined:_isUndefined}=__webpack_require__("./node_modules/jsonld/lib/types.js"),{isList:_isList,isValue:_isValue,isGraph:_isGraph,isSubject:_isSubject}=__webpack_require__("./node_modules/jsonld/lib/graphTypes.js"),{expandIri:_expandIri,getContextValue:_getContextValue,isKeyword:_isKeyword,process:_processContext,processingMode:_processingMode}=__webpack_require__("./node_modules/jsonld/lib/context.js"),{isAbsolute:_isAbsoluteIri}=__webpack_require__("./node_modules/jsonld/lib/url.js"),{REGEX_BCP47,REGEX_KEYWORD,addValue:_addValue,asArray:_asArray,getValues:_getValues,validateTypeValue:_validateTypeValue}=__webpack_require__("./node_modules/jsonld/lib/util.js"),{handleEvent:_handleEvent}=__webpack_require__("./node_modules/jsonld/lib/events.js"),api={};function _dropUnsafeObject({value,count,options}){if(0===count||"@value"in value||"@list"in value||1===count&&"@id"in value){if(options.eventHandler){let code,message;0===count?(code="empty object",message="Dropping empty object."):"@value"in value?(code="object with only @value",message="Dropping object with only @value."):"@list"in value?(code="object with only @list",message="Dropping object with only @list."):1===count&&"@id"in value&&(code="object with only @id",message="Dropping object with only @id."),_handleEvent({event:{type:["JsonLdEvent"],code,level:"warning",message,details:{value}},options})}return null}return value}async function _expandObject({activeCtx,activeProperty,expandedActiveProperty,element,expandedParent,options={},insideList,typeKey,typeScopedContext}){const keys=Object.keys(element).sort(),nests=[];let unexpandedValue;const isJsonType=element[typeKey]&&"@json"===_expandIri(activeCtx,_isArray(element[typeKey])?element[typeKey][0]:element[typeKey],{vocab:!0},{...options,typeExpansion:!0});for(const key of keys){let expandedValue,value=element[key];if("@context"===key)continue;const expandedProperty=_expandIri(activeCtx,key,{vocab:!0},options);if(null===expandedProperty||!_isAbsoluteIri(expandedProperty)&&!_isKeyword(expandedProperty)){options.eventHandler&&_handleEvent({event:{type:["JsonLdEvent"],code:"invalid property",level:"warning",message:"Dropping property that did not expand into an absolute IRI or keyword.",details:{property:key,expandedProperty}},options});continue}if(_isKeyword(expandedProperty)){if("@reverse"===expandedActiveProperty)throw new JsonLdError("Invalid JSON-LD syntax; a keyword cannot be used as a @reverse property.","jsonld.SyntaxError",{code:"invalid reverse property map",value});if(expandedProperty in expandedParent&&"@included"!==expandedProperty&&"@type"!==expandedProperty)throw new JsonLdError("Invalid JSON-LD syntax; colliding keywords detected.","jsonld.SyntaxError",{code:"colliding keywords",keyword:expandedProperty})}if("@id"===expandedProperty){if(!_isString(value)){if(!options.isFrame)throw new JsonLdError('Invalid JSON-LD syntax; "@id" value must a string.',"jsonld.SyntaxError",{code:"invalid @id value",value});if(_isObject(value)){if(!_isEmptyObject(value))throw new JsonLdError('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',"jsonld.SyntaxError",{code:"invalid @id value",value})}else{if(!_isArray(value))throw new JsonLdError('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',"jsonld.SyntaxError",{code:"invalid @id value",value});if(!value.every((v=>_isString(v))))throw new JsonLdError('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',"jsonld.SyntaxError",{code:"invalid @id value",value})}}_addValue(expandedParent,"@id",_asArray(value).map((v=>{if(_isString(v)){const ve=_expandIri(activeCtx,v,{base:!0},options);return options.eventHandler&&(null===ve?_handleEvent(null===v?{event:{type:["JsonLdEvent"],code:"null @id value",level:"warning",message:"Null @id found.",details:{id:v}},options}:{event:{type:["JsonLdEvent"],code:"reserved @id value",level:"warning",message:"Reserved @id found.",details:{id:v}},options}):_isAbsoluteIri(ve)||_handleEvent({event:{type:["JsonLdEvent"],code:"relative @id reference",level:"warning",message:"Relative @id reference found.",details:{id:v,expandedId:ve}},options})),ve}return v})),{propertyIsArray:options.isFrame});continue}if("@type"===expandedProperty){_isObject(value)&&(value=Object.fromEntries(Object.entries(value).map((([k,v])=>[_expandIri(typeScopedContext,k,{vocab:!0}),_asArray(v).map((vv=>_expandIri(typeScopedContext,vv,{base:!0,vocab:!0},{...options,typeExpansion:!0})))])))),_validateTypeValue(value,options.isFrame),_addValue(expandedParent,"@type",_asArray(value).map((v=>{if(_isString(v)){const ve=_expandIri(typeScopedContext,v,{base:!0,vocab:!0},{...options,typeExpansion:!0});return"@json"===ve||_isAbsoluteIri(ve)||options.eventHandler&&_handleEvent({event:{type:["JsonLdEvent"],code:"relative @type reference",level:"warning",message:"Relative @type reference found.",details:{type:v}},options}),ve}return v})),{propertyIsArray:!!options.isFrame});continue}if("@included"===expandedProperty&&_processingMode(activeCtx,1.1)){const includedResult=_asArray(await api.expand({activeCtx,activeProperty,element:value,options}));if(!includedResult.every((v=>_isSubject(v))))throw new JsonLdError("Invalid JSON-LD syntax; values of @included must expand to node objects.","jsonld.SyntaxError",{code:"invalid @included value",value});_addValue(expandedParent,"@included",includedResult,{propertyIsArray:!0});continue}if("@graph"===expandedProperty&&!_isObject(value)&&!_isArray(value))throw new JsonLdError('Invalid JSON-LD syntax; "@graph" value must not be an object or an array.',"jsonld.SyntaxError",{code:"invalid @graph value",value});if("@value"===expandedProperty){unexpandedValue=value,isJsonType&&_processingMode(activeCtx,1.1)?expandedParent["@value"]=value:_addValue(expandedParent,"@value",value,{propertyIsArray:options.isFrame});continue}if("@language"===expandedProperty){if(null===value)continue;if(!_isString(value)&&!options.isFrame)throw new JsonLdError('Invalid JSON-LD syntax; "@language" value must be a string.',"jsonld.SyntaxError",{code:"invalid language-tagged string",value});value=_asArray(value).map((v=>_isString(v)?v.toLowerCase():v));for(const language of value)_isString(language)&&!language.match(REGEX_BCP47)&&options.eventHandler&&_handleEvent({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language}},options});_addValue(expandedParent,"@language",value,{propertyIsArray:options.isFrame});continue}if("@direction"===expandedProperty){if(!_isString(value)&&!options.isFrame)throw new JsonLdError('Invalid JSON-LD syntax; "@direction" value must be a string.',"jsonld.SyntaxError",{code:"invalid base direction",value});value=_asArray(value);for(const dir of value)if(_isString(dir)&&"ltr"!==dir&&"rtl"!==dir)throw new JsonLdError('Invalid JSON-LD syntax; "@direction" must be "ltr" or "rtl".',"jsonld.SyntaxError",{code:"invalid base direction",value});_addValue(expandedParent,"@direction",value,{propertyIsArray:options.isFrame});continue}if("@index"===expandedProperty){if(!_isString(value))throw new JsonLdError('Invalid JSON-LD syntax; "@index" value must be a string.',"jsonld.SyntaxError",{code:"invalid @index value",value});_addValue(expandedParent,"@index",value);continue}if("@reverse"===expandedProperty){if(!_isObject(value))throw new JsonLdError('Invalid JSON-LD syntax; "@reverse" value must be an object.',"jsonld.SyntaxError",{code:"invalid @reverse value",value});if(expandedValue=await api.expand({activeCtx,activeProperty:"@reverse",element:value,options}),"@reverse"in expandedValue)for(const property in expandedValue["@reverse"])_addValue(expandedParent,property,expandedValue["@reverse"][property],{propertyIsArray:!0});let reverseMap=expandedParent["@reverse"]||null;for(const property in expandedValue){if("@reverse"===property)continue;null===reverseMap&&(reverseMap=expandedParent["@reverse"]={}),_addValue(reverseMap,property,[],{propertyIsArray:!0});const items=expandedValue[property];for(let ii=0;ii<items.length;++ii){const item=items[ii];if(_isValue(item)||_isList(item))throw new JsonLdError('Invalid JSON-LD syntax; "@reverse" value must not be a @value or an @list.',"jsonld.SyntaxError",{code:"invalid reverse property value",value:expandedValue});_addValue(reverseMap,property,item,{propertyIsArray:!0})}}continue}if("@nest"===expandedProperty){nests.push(key);continue}let termCtx=activeCtx;const ctx=_getContextValue(activeCtx,key,"@context");_isUndefined(ctx)||(termCtx=await _processContext({activeCtx,localCtx:ctx,propagate:!0,overrideProtected:!0,options}));const container=_getContextValue(activeCtx,key,"@container")||[];if(container.includes("@language")&&_isObject(value)){expandedValue=_expandLanguageMap(termCtx,value,_getContextValue(termCtx,key,"@direction"),options)}else if(container.includes("@index")&&_isObject(value)){const asGraph=container.includes("@graph"),indexKey=_getContextValue(termCtx,key,"@index")||"@index",propertyIndex="@index"!==indexKey&&_expandIri(activeCtx,indexKey,{vocab:!0},options);expandedValue=await _expandIndexMap({activeCtx:termCtx,options,activeProperty:key,value,asGraph,indexKey,propertyIndex})}else if(container.includes("@id")&&_isObject(value)){const asGraph=container.includes("@graph");expandedValue=await _expandIndexMap({activeCtx:termCtx,options,activeProperty:key,value,asGraph,indexKey:"@id"})}else if(container.includes("@type")&&_isObject(value))expandedValue=await _expandIndexMap({activeCtx:termCtx.revertToPreviousContext(),options,activeProperty:key,value,asGraph:!1,indexKey:"@type"});else{const isList="@list"===expandedProperty;if(isList||"@set"===expandedProperty){let nextActiveProperty=activeProperty;isList&&"@graph"===expandedActiveProperty&&(nextActiveProperty=null),expandedValue=await api.expand({activeCtx:termCtx,activeProperty:nextActiveProperty,element:value,options,insideList:isList})}else expandedValue="@json"===_getContextValue(activeCtx,key,"@type")?{"@type":"@json","@value":value}:await api.expand({activeCtx:termCtx,activeProperty:key,element:value,options,insideList:!1})}if(null!==expandedValue||"@value"===expandedProperty){if("@list"!==expandedProperty&&!_isList(expandedValue)&&container.includes("@list")&&(expandedValue={"@list":_asArray(expandedValue)}),container.includes("@graph")&&!container.some((key=>"@id"===key||"@index"===key))){if(expandedValue=_asArray(expandedValue),options.isFrame||(expandedValue=expandedValue.filter((v=>null!==_dropUnsafeObject({value:v,count:Object.keys(v).length,options})))),0===expandedValue.length)continue;expandedValue=expandedValue.map((v=>({"@graph":_asArray(v)})))}if(termCtx.mappings.has(key)&&termCtx.mappings.get(key).reverse){const reverseMap=expandedParent["@reverse"]=expandedParent["@reverse"]||{};expandedValue=_asArray(expandedValue);for(let ii=0;ii<expandedValue.length;++ii){const item=expandedValue[ii];if(_isValue(item)||_isList(item))throw new JsonLdError('Invalid JSON-LD syntax; "@reverse" value must not be a @value or an @list.',"jsonld.SyntaxError",{code:"invalid reverse property value",value:expandedValue});_addValue(reverseMap,expandedProperty,item,{propertyIsArray:!0})}}else _addValue(expandedParent,expandedProperty,expandedValue,{propertyIsArray:!0})}}if("@value"in expandedParent)if("@json"===expandedParent["@type"]&&_processingMode(activeCtx,1.1));else if((_isObject(unexpandedValue)||_isArray(unexpandedValue))&&!options.isFrame)throw new JsonLdError('Invalid JSON-LD syntax; "@value" value must not be an object or an array.',"jsonld.SyntaxError",{code:"invalid value object value",value:unexpandedValue});for(const key of nests){const nestedValues=_isArray(element[key])?element[key]:[element[key]];for(const nv of nestedValues){if(!_isObject(nv)||Object.keys(nv).some((k=>"@value"===_expandIri(activeCtx,k,{vocab:!0},options))))throw new JsonLdError("Invalid JSON-LD syntax; nested value must be a node object.","jsonld.SyntaxError",{code:"invalid @nest value",value:nv});await _expandObject({activeCtx,activeProperty,expandedActiveProperty,element:nv,expandedParent,options,insideList,typeScopedContext,typeKey})}}}function _expandValue({activeCtx,activeProperty,value,options}){if(null==value)return null;const expandedProperty=_expandIri(activeCtx,activeProperty,{vocab:!0},options);if("@id"===expandedProperty)return _expandIri(activeCtx,value,{base:!0},options);if("@type"===expandedProperty)return _expandIri(activeCtx,value,{vocab:!0,base:!0},{...options,typeExpansion:!0});const type=_getContextValue(activeCtx,activeProperty,"@type");if(("@id"===type||"@graph"===expandedProperty)&&_isString(value)){const expandedValue=_expandIri(activeCtx,value,{base:!0},options);return null===expandedValue&&value.match(REGEX_KEYWORD)&&options.eventHandler&&_handleEvent({event:{type:["JsonLdEvent"],code:"reserved @id value",level:"warning",message:"Reserved @id found.",details:{id:activeProperty}},options}),{"@id":expandedValue}}if("@vocab"===type&&_isString(value))return{"@id":_expandIri(activeCtx,value,{vocab:!0,base:!0},options)};if(_isKeyword(expandedProperty))return value;const rval={};if(type&&!["@id","@vocab","@none"].includes(type))rval["@type"]=type;else if(_isString(value)){const language=_getContextValue(activeCtx,activeProperty,"@language");null!==language&&(rval["@language"]=language);const direction=_getContextValue(activeCtx,activeProperty,"@direction");null!==direction&&(rval["@direction"]=direction)}return["boolean","number","string"].includes(typeof value)||(value=value.toString()),rval["@value"]=value,rval}function _expandLanguageMap(activeCtx,languageMap,direction,options){const rval=[],keys=Object.keys(languageMap).sort();for(const key of keys){const expandedKey=_expandIri(activeCtx,key,{vocab:!0},options);let val=languageMap[key];_isArray(val)||(val=[val]);for(const item of val){if(null===item)continue;if(!_isString(item))throw new JsonLdError("Invalid JSON-LD syntax; language map values must be strings.","jsonld.SyntaxError",{code:"invalid language map value",languageMap});const val={"@value":item};"@none"!==expandedKey&&(key.match(REGEX_BCP47)||options.eventHandler&&_handleEvent({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:key}},options}),val["@language"]=key.toLowerCase()),direction&&(val["@direction"]=direction),rval.push(val)}}return rval}async function _expandIndexMap({activeCtx,options,activeProperty,value,asGraph,indexKey,propertyIndex}){const rval=[],keys=Object.keys(value).sort(),isTypeIndex="@type"===indexKey;for(let key of keys){if(isTypeIndex){const ctx=_getContextValue(activeCtx,key,"@context");_isUndefined(ctx)||(activeCtx=await _processContext({activeCtx,localCtx:ctx,propagate:!1,options}))}let expandedKey,val=value[key];_isArray(val)||(val=[val]),val=await api.expand({activeCtx,activeProperty,element:val,options,insideList:!1,insideIndex:!0}),expandedKey=propertyIndex?"@none"===key?"@none":_expandValue({activeCtx,activeProperty:indexKey,value:key,options}):_expandIri(activeCtx,key,{vocab:!0},options),"@id"===indexKey?key=_expandIri(activeCtx,key,{base:!0},options):isTypeIndex&&(key=expandedKey);for(let item of val){if(asGraph&&!_isGraph(item)&&(item={"@graph":[item]}),"@type"===indexKey)"@none"===expandedKey||(item["@type"]?item["@type"]=[key].concat(item["@type"]):item["@type"]=[key]);else{if(_isValue(item)&&!["@language","@type","@index"].includes(indexKey))throw new JsonLdError(`Invalid JSON-LD syntax; Attempt to add illegal key to value object: "${indexKey}".`,"jsonld.SyntaxError",{code:"invalid value object",value:item});propertyIndex?"@none"!==expandedKey&&_addValue(item,propertyIndex,expandedKey,{propertyIsArray:!0,prependValue:!0}):"@none"===expandedKey||indexKey in item||(item[indexKey]=key)}rval.push(item)}}return rval}module.exports=api,api.expand=async({activeCtx,activeProperty=null,element,options={},insideList=!1,insideIndex=!1,typeScopedContext=null})=>{if(null==element)return null;if("@default"===activeProperty&&(options=Object.assign({},options,{isFrame:!1})),!_isArray(element)&&!_isObject(element))return insideList||null!==activeProperty&&"@graph"!==_expandIri(activeCtx,activeProperty,{vocab:!0},options)?_expandValue({activeCtx,activeProperty,value:element,options}):(options.eventHandler&&_handleEvent({event:{type:["JsonLdEvent"],code:"free-floating scalar",level:"warning",message:"Dropping free-floating scalar not in a list.",details:{value:element}},options}),null);if(_isArray(element)){let rval=[];const container=_getContextValue(activeCtx,activeProperty,"@container")||[];insideList=insideList||container.includes("@list");for(let i=0;i<element.length;++i){let e=await api.expand({activeCtx,activeProperty,element:element[i],options,insideIndex,typeScopedContext});insideList&&_isArray(e)&&(e={"@list":e}),null!==e&&(_isArray(e)?rval=rval.concat(e):rval.push(e))}return rval}const expandedActiveProperty=_expandIri(activeCtx,activeProperty,{vocab:!0},options),propertyScopedCtx=_getContextValue(activeCtx,activeProperty,"@context");typeScopedContext=typeScopedContext||(activeCtx.previousContext?activeCtx:null);let keys=Object.keys(element).sort(),mustRevert=!insideIndex;if(mustRevert&&typeScopedContext&&keys.length<=2&&!keys.includes("@context"))for(const key of keys){const expandedProperty=_expandIri(typeScopedContext,key,{vocab:!0},options);if("@value"===expandedProperty){mustRevert=!1,activeCtx=typeScopedContext;break}if("@id"===expandedProperty&&1===keys.length){mustRevert=!1;break}}mustRevert&&(activeCtx=activeCtx.revertToPreviousContext()),_isUndefined(propertyScopedCtx)||(activeCtx=await _processContext({activeCtx,localCtx:propertyScopedCtx,propagate:!0,overrideProtected:!0,options})),"@context"in element&&(activeCtx=await _processContext({activeCtx,localCtx:element["@context"],options})),typeScopedContext=activeCtx;let typeKey=null;for(const key of keys){if("@type"===_expandIri(activeCtx,key,{vocab:!0},options)){typeKey=typeKey||key;const value=element[key],types=Array.isArray(value)?value.length>1?value.slice().sort():value:[value];for(const type of types){const ctx=_getContextValue(typeScopedContext,type,"@context");_isUndefined(ctx)||(activeCtx=await _processContext({activeCtx,localCtx:ctx,options,propagate:!1}))}}}let rval={};await _expandObject({activeCtx,activeProperty,expandedActiveProperty,element,expandedParent:rval,options,insideList,typeKey,typeScopedContext}),keys=Object.keys(rval);let count=keys.length;if("@value"in rval){if("@type"in rval&&("@language"in rval||"@direction"in rval))throw new JsonLdError('Invalid JSON-LD syntax; an element containing "@value" may not contain both "@type" and either "@language" or "@direction".',"jsonld.SyntaxError",{code:"invalid value object",element:rval});let validCount=count-1;if("@type"in rval&&(validCount-=1),"@index"in rval&&(validCount-=1),"@language"in rval&&(validCount-=1),"@direction"in rval&&(validCount-=1),0!==validCount)throw new JsonLdError('Invalid JSON-LD syntax; an element containing "@value" may only have an "@index" property and either "@type" or either or both "@language" or "@direction".',"jsonld.SyntaxError",{code:"invalid value object",element:rval});const values=null===rval["@value"]?[]:_asArray(rval["@value"]),types=_getValues(rval,"@type");if(_processingMode(activeCtx,1.1)&&types.includes("@json")&&1===types.length);else if(0===values.length)options.eventHandler&&_handleEvent({event:{type:["JsonLdEvent"],code:"null @value value",level:"warning",message:"Dropping null @value value.",details:{value:rval}},options}),rval=null;else{if(!values.every((v=>_isString(v)||_isEmptyObject(v)))&&"@language"in rval)throw new JsonLdError("Invalid JSON-LD syntax; only strings may be language-tagged.","jsonld.SyntaxError",{code:"invalid language-tagged value",element:rval});if(!types.every((t=>_isAbsoluteIri(t)&&!(_isString(t)&&0===t.indexOf("_:"))||_isEmptyObject(t))))throw new JsonLdError('Invalid JSON-LD syntax; an element containing "@value" and "@type" must have an absolute IRI for the value of "@type".',"jsonld.SyntaxError",{code:"invalid typed value",element:rval})}}else if("@type"in rval&&!_isArray(rval["@type"]))rval["@type"]=[rval["@type"]];else if("@set"in rval||"@list"in rval){if(count>1&&(2!==count||!("@index"in rval)))throw new JsonLdError('Invalid JSON-LD syntax; if an element has the property "@set" or "@list", then it can have at most one other property that is "@index".',"jsonld.SyntaxError",{code:"invalid set or list object",element:rval});"@set"in rval&&(rval=rval["@set"],keys=Object.keys(rval),count=keys.length)}else 1===count&&"@language"in rval&&(options.eventHandler&&_handleEvent({event:{type:["JsonLdEvent"],code:"object with only @language",level:"warning",message:"Dropping object with only @language.",details:{value:rval}},options}),rval=null);return!_isObject(rval)||options.keepFreeFloatingNodes||insideList||null!==activeProperty&&"@graph"!==expandedActiveProperty&&!(_getContextValue(activeCtx,activeProperty,"@container")||[]).includes("@graph")||(rval=_dropUnsafeObject({value:rval,count,options})),rval}},"./node_modules/jsonld/lib/flatten.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";const{isSubjectReference:_isSubjectReference}=__webpack_require__("./node_modules/jsonld/lib/graphTypes.js"),{createMergedNodeMap:_createMergedNodeMap}=__webpack_require__("./node_modules/jsonld/lib/nodeMap.js"),api={};module.exports=api,api.flatten=input=>{const defaultGraph=_createMergedNodeMap(input),flattened=[],keys=Object.keys(defaultGraph).sort();for(let ki=0;ki<keys.length;++ki){const node=defaultGraph[keys[ki]];_isSubjectReference(node)||flattened.push(node)}return flattened}},"./node_modules/jsonld/lib/frame.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";const{isKeyword}=__webpack_require__("./node_modules/jsonld/lib/context.js"),graphTypes=__webpack_require__("./node_modules/jsonld/lib/graphTypes.js"),types=__webpack_require__("./node_modules/jsonld/lib/types.js"),util=__webpack_require__("./node_modules/jsonld/lib/util.js"),url=__webpack_require__("./node_modules/jsonld/lib/url.js"),JsonLdError=__webpack_require__("./node_modules/jsonld/lib/JsonLdError.js"),{createNodeMap:_createNodeMap,mergeNodeMapGraphs:_mergeNodeMapGraphs}=__webpack_require__("./node_modules/jsonld/lib/nodeMap.js"),api={};function _createImplicitFrame(flags){const frame={};for(const key in flags)void 0!==flags[key]&&(frame["@"+key]=[flags[key]]);return[frame]}function _createsCircularReference(subjectToEmbed,graph,subjectStack){for(let i=subjectStack.length-1;i>=0;--i){const subject=subjectStack[i];if(subject.graph===graph&&subject.subject["@id"]===subjectToEmbed["@id"])return!0}return!1}function _getFrameFlag(frame,options,name){const flag="@"+name;let rval=flag in frame?frame[flag][0]:options[name];if("embed"===name)if(!0===rval)rval="@once";else if(!1===rval)rval="@never";else if("@always"!==rval&&"@never"!==rval&&"@link"!==rval&&"@first"!==rval&&"@last"!==rval&&"@once"!==rval)throw new JsonLdError("Invalid JSON-LD syntax; invalid value of @embed.","jsonld.SyntaxError",{code:"invalid @embed value",frame});return rval}function _validateFrame(frame){if(!types.isArray(frame)||1!==frame.length||!types.isObject(frame[0]))throw new JsonLdError("Invalid JSON-LD syntax; a JSON-LD frame must be a single object.","jsonld.SyntaxError",{frame});if("@id"in frame[0])for(const id of util.asArray(frame[0]["@id"]))if(!types.isObject(id)&&!url.isAbsolute(id)||types.isString(id)&&0===id.indexOf("_:"))throw new JsonLdError("Invalid JSON-LD syntax; invalid @id in frame.","jsonld.SyntaxError",{code:"invalid frame",frame});if("@type"in frame[0])for(const type of util.asArray(frame[0]["@type"]))if(!types.isObject(type)&&!url.isAbsolute(type)&&"@json"!==type||types.isString(type)&&0===type.indexOf("_:"))throw new JsonLdError("Invalid JSON-LD syntax; invalid @type in frame.","jsonld.SyntaxError",{code:"invalid frame",frame})}function _filterSubject(state,subject,frame,flags){let wildcard=!0,matchesSome=!1;for(const key in frame){let matchThis=!1;const nodeValues=util.getValues(subject,key),isEmpty=0===util.getValues(frame,key).length;if("@id"===key){if(types.isEmptyObject(frame["@id"][0]||{})?matchThis=!0:frame["@id"].length>=0&&(matchThis=frame["@id"].includes(nodeValues[0])),!flags.requireAll)return matchThis}else if("@type"===key){if(wildcard=!1,isEmpty){if(nodeValues.length>0)return!1;matchThis=!0}else if(1===frame["@type"].length&&types.isEmptyObject(frame["@type"][0]))matchThis=nodeValues.length>0;else for(const type of frame["@type"])matchThis=!(!types.isObject(type)||!("@default"in type))||(matchThis||nodeValues.some((tt=>tt===type)));if(!flags.requireAll)return matchThis}else{if(isKeyword(key))continue;{const thisFrame=util.getValues(frame,key)[0];let hasDefault=!1;if(thisFrame&&(_validateFrame([thisFrame]),hasDefault="@default"in thisFrame),wildcard=!1,0===nodeValues.length&&hasDefault)continue;if(nodeValues.length>0&&isEmpty)return!1;if(void 0===thisFrame){if(nodeValues.length>0)return!1;matchThis=!0}else if(graphTypes.isList(thisFrame)){const listValue=thisFrame["@list"][0];if(graphTypes.isList(nodeValues[0])){const nodeListValues=nodeValues[0]["@list"];graphTypes.isValue(listValue)?matchThis=nodeListValues.some((lv=>_valueMatch(listValue,lv))):(graphTypes.isSubject(listValue)||graphTypes.isSubjectReference(listValue))&&(matchThis=nodeListValues.some((lv=>_nodeMatch(state,listValue,lv,flags))))}}else matchThis=graphTypes.isValue(thisFrame)?nodeValues.some((nv=>_valueMatch(thisFrame,nv))):graphTypes.isSubjectReference(thisFrame)?nodeValues.some((nv=>_nodeMatch(state,thisFrame,nv,flags))):!!types.isObject(thisFrame)&&nodeValues.length>0}}if(!matchThis&&flags.requireAll)return!1;matchesSome=matchesSome||matchThis}return wildcard||matchesSome}function _removeEmbed(state,id){const embeds=state.uniqueEmbeds[state.graph],embed=embeds[id],parent=embed.parent,property=embed.property,subject={"@id":id};if(types.isArray(parent)){for(let i=0;i<parent.length;++i)if(util.compareValues(parent[i],subject)){parent[i]=subject;break}}else{const useArray=types.isArray(parent[property]);util.removeValue(parent,property,subject,{propertyIsArray:useArray}),util.addValue(parent,property,subject,{propertyIsArray:useArray})}const removeDependents=id=>{const ids=Object.keys(embeds);for(const next of ids)next in embeds&&types.isObject(embeds[next].parent)&&embeds[next].parent["@id"]===id&&(delete embeds[next],removeDependents(next))};removeDependents(id)}function _cleanupPreserve(input,options){if(types.isArray(input))return input.map((value=>_cleanupPreserve(value,options)));if(types.isObject(input)){if("@preserve"in input)return input["@preserve"][0];if(graphTypes.isValue(input))return input;if(graphTypes.isList(input))return input["@list"]=_cleanupPreserve(input["@list"],options),input;if("@id"in input){const id=input["@id"];if(options.link.hasOwnProperty(id)){const idx=options.link[id].indexOf(input);if(-1!==idx)return options.link[id][idx];options.link[id].push(input)}else options.link[id]=[input]}for(const prop in input)"@id"===prop&&options.bnodesToClear.includes(input[prop])?delete input["@id"]:input[prop]=_cleanupPreserve(input[prop],options)}return input}function _addFrameOutput(parent,property,output){types.isObject(parent)?util.addValue(parent,property,output,{propertyIsArray:!0}):parent.push(output)}function _nodeMatch(state,pattern,value,flags){if(!("@id"in value))return!1;const nodeObject=state.subjects[value["@id"]];return nodeObject&&_filterSubject(state,nodeObject,pattern,flags)}function _valueMatch(pattern,value){const v1=value["@value"],t1=value["@type"],l1=value["@language"],v2=pattern["@value"]?types.isArray(pattern["@value"])?pattern["@value"]:[pattern["@value"]]:[],t2=pattern["@type"]?types.isArray(pattern["@type"])?pattern["@type"]:[pattern["@type"]]:[],l2=pattern["@language"]?types.isArray(pattern["@language"])?pattern["@language"]:[pattern["@language"]]:[];return 0===v2.length&&0===t2.length&&0===l2.length||!(!v2.includes(v1)&&!types.isEmptyObject(v2[0]))&&(!!(!t1&&0===t2.length||t2.includes(t1)||t1&&types.isEmptyObject(t2[0]))&&!!(!l1&&0===l2.length||l2.includes(l1)||l1&&types.isEmptyObject(l2[0])))}module.exports=api,api.frameMergedOrDefault=(input,frame,options)=>{const state={options,embedded:!1,graph:"@default",graphMap:{"@default":{}},subjectStack:[],link:{},bnodeMap:{}},issuer=new util.IdentifierIssuer("_:b");_createNodeMap(input,state.graphMap,"@default",issuer),options.merged&&(state.graphMap["@merged"]=_mergeNodeMapGraphs(state.graphMap),state.graph="@merged"),state.subjects=state.graphMap[state.graph];const framed=[];return api.frame(state,Object.keys(state.subjects).sort(),frame,framed),options.pruneBlankNodeIdentifiers&&(options.bnodesToClear=Object.keys(state.bnodeMap).filter((id=>1===state.bnodeMap[id].length))),options.link={},_cleanupPreserve(framed,options)},api.frame=(state,subjects,frame,parent,property=null)=>{_validateFrame(frame),frame=frame[0];const options=state.options,flags={embed:_getFrameFlag(frame,options,"embed"),explicit:_getFrameFlag(frame,options,"explicit"),requireAll:_getFrameFlag(frame,options,"requireAll")};state.link.hasOwnProperty(state.graph)||(state.link[state.graph]={});const link=state.link[state.graph],matches=function _filterSubjects(state,subjects,frame,flags){const rval={};for(const id of subjects){const subject=state.graphMap[state.graph][id];_filterSubject(state,subject,frame,flags)&&(rval[id]=subject)}return rval}(state,subjects,frame,flags),ids=Object.keys(matches).sort();for(const id of ids){const subject=matches[id];if(null===property?state.uniqueEmbeds={[state.graph]:{}}:state.uniqueEmbeds[state.graph]=state.uniqueEmbeds[state.graph]||{},"@link"===flags.embed&&id in link){_addFrameOutput(parent,property,link[id]);continue}const output={"@id":id};if(0===id.indexOf("_:")&&util.addValue(state.bnodeMap,id,output,{propertyIsArray:!0}),link[id]=output,("@first"===flags.embed||"@last"===flags.embed)&&state.is11)throw new JsonLdError("Invalid JSON-LD syntax; invalid value of @embed.","jsonld.SyntaxError",{code:"invalid @embed value",frame});if(state.embedded||!state.uniqueEmbeds[state.graph].hasOwnProperty(id))if(!state.embedded||"@never"!==flags.embed&&!_createsCircularReference(subject,state.graph,state.subjectStack))if(!state.embedded||"@first"!=flags.embed&&"@once"!=flags.embed||!state.uniqueEmbeds[state.graph].hasOwnProperty(id)){if("@last"===flags.embed&&id in state.uniqueEmbeds[state.graph]&&_removeEmbed(state,id),state.uniqueEmbeds[state.graph][id]={parent,property},state.subjectStack.push({subject,graph:state.graph}),id in state.graphMap){let recurse=!1,subframe=null;"@graph"in frame?(subframe=frame["@graph"][0],recurse=!("@merged"===id||"@default"===id),types.isObject(subframe)||(subframe={})):(recurse="@merged"!==state.graph,subframe={}),recurse&&api.frame({...state,graph:id,embedded:!1},Object.keys(state.graphMap[id]).sort(),[subframe],output,"@graph")}"@included"in frame&&api.frame({...state,embedded:!1},subjects,frame["@included"],output,"@included");for(const prop of Object.keys(subject).sort())if(isKeyword(prop)){if(output[prop]=util.clone(subject[prop]),"@type"===prop)for(const type of subject["@type"])0===type.indexOf("_:")&&util.addValue(state.bnodeMap,type,output,{propertyIsArray:!0})}else if(!flags.explicit||prop in frame)for(const o of subject[prop]){const subframe=prop in frame?frame[prop]:_createImplicitFrame(flags);if(graphTypes.isList(o)){const subframe=frame[prop]&&frame[prop][0]&&frame[prop][0]["@list"]?frame[prop][0]["@list"]:_createImplicitFrame(flags),list={"@list":[]};_addFrameOutput(output,prop,list);const src=o["@list"];for(const oo of src)graphTypes.isSubjectReference(oo)?api.frame({...state,embedded:!0},[oo["@id"]],subframe,list,"@list"):_addFrameOutput(list,"@list",util.clone(oo))}else graphTypes.isSubjectReference(o)?api.frame({...state,embedded:!0},[o["@id"]],subframe,output,prop):_valueMatch(subframe[0],o)&&_addFrameOutput(output,prop,util.clone(o))}for(const prop of Object.keys(frame).sort()){if("@type"===prop){if(!types.isObject(frame[prop][0])||!("@default"in frame[prop][0]))continue}else if(isKeyword(prop))continue;const next=frame[prop][0]||{};if(!_getFrameFlag(next,options,"omitDefault")&&!(prop in output)){let preserve="@null";"@default"in next&&(preserve=util.clone(next["@default"])),types.isArray(preserve)||(preserve=[preserve]),output[prop]=[{"@preserve":preserve}]}}for(const reverseProp of Object.keys(frame["@reverse"]||{}).sort()){const subframe=frame["@reverse"][reverseProp];for(const subject of Object.keys(state.subjects)){util.getValues(state.subjects[subject],reverseProp).some((v=>v["@id"]===id))&&(output["@reverse"]=output["@reverse"]||{},util.addValue(output["@reverse"],reverseProp,[],{propertyIsArray:!0}),api.frame({...state,embedded:!0},[subject],subframe,output["@reverse"][reverseProp],property))}}_addFrameOutput(parent,property,output),state.subjectStack.pop()}else _addFrameOutput(parent,property,output);else _addFrameOutput(parent,property,output)}},api.cleanupNull=(input,options)=>{if(types.isArray(input)){return input.map((v=>api.cleanupNull(v,options))).filter((v=>v))}if("@null"===input)return null;if(types.isObject(input)){if("@id"in input){const id=input["@id"];if(options.link.hasOwnProperty(id)){const idx=options.link[id].indexOf(input);if(-1!==idx)return options.link[id][idx];options.link[id].push(input)}else options.link[id]=[input]}for(const key in input)input[key]=api.cleanupNull(input[key],options)}return input}},"./node_modules/jsonld/lib/fromRdf.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";const JsonLdError=__webpack_require__("./node_modules/jsonld/lib/JsonLdError.js"),graphTypes=__webpack_require__("./node_modules/jsonld/lib/graphTypes.js"),types=__webpack_require__("./node_modules/jsonld/lib/types.js"),{REGEX_BCP47,addValue:_addValue}=__webpack_require__("./node_modules/jsonld/lib/util.js"),{handleEvent:_handleEvent}=__webpack_require__("./node_modules/jsonld/lib/events.js"),{RDF_LIST,RDF_FIRST,RDF_REST,RDF_NIL,RDF_TYPE,RDF_JSON_LITERAL,XSD_BOOLEAN,XSD_DOUBLE,XSD_INTEGER,XSD_STRING}=__webpack_require__("./node_modules/jsonld/lib/constants.js"),api={};function _RDFToObject(o,useNativeTypes,rdfDirection,options){if(o.termType.endsWith("Node"))return{"@id":o.value};const rval={"@value":o.value};if(o.language)o.language.match(REGEX_BCP47)||options.eventHandler&&_handleEvent({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:o.language}},options}),rval["@language"]=o.language;else{let type=o.datatype.value;if(type||(type=XSD_STRING),type===RDF_JSON_LITERAL){type="@json";try{rval["@value"]=JSON.parse(rval["@value"])}catch(e){throw new JsonLdError("JSON literal could not be parsed.","jsonld.InvalidJsonLiteral",{code:"invalid JSON literal",value:rval["@value"],cause:e})}}if(useNativeTypes){if(type===XSD_BOOLEAN)"true"===rval["@value"]?rval["@value"]=!0:"false"===rval["@value"]&&(rval["@value"]=!1);else if(types.isNumeric(rval["@value"]))if(type===XSD_INTEGER){const i=parseInt(rval["@value"],10);i.toFixed(0)===rval["@value"]&&(rval["@value"]=i)}else type===XSD_DOUBLE&&(rval["@value"]=parseFloat(rval["@value"]));[XSD_BOOLEAN,XSD_INTEGER,XSD_DOUBLE,XSD_STRING].includes(type)||(rval["@type"]=type)}else if("i18n-datatype"===rdfDirection&&type.startsWith("https://www.w3.org/ns/i18n#")){const[,language,direction]=type.split(/[#_]/);language.length>0&&(rval["@language"]=language,language.match(REGEX_BCP47)||options.eventHandler&&_handleEvent({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language}},options})),rval["@direction"]=direction}else type!==XSD_STRING&&(rval["@type"]=type)}return rval}module.exports=api,api.fromRDF=async(dataset,options)=>{const{useRdfType=!1,useNativeTypes=!1,rdfDirection=null}=options,defaultGraph={},graphMap={"@default":defaultGraph},referencedOnce={};if(rdfDirection){if("compound-literal"===rdfDirection)throw new JsonLdError("Unsupported rdfDirection value.","jsonld.InvalidRdfDirection",{value:rdfDirection});if("i18n-datatype"!==rdfDirection)throw new JsonLdError("Unknown rdfDirection value.","jsonld.InvalidRdfDirection",{value:rdfDirection})}for(const quad of dataset){const name="DefaultGraph"===quad.graph.termType?"@default":quad.graph.value;name in graphMap||(graphMap[name]={}),"@default"===name||name in defaultGraph||(defaultGraph[name]={"@id":name});const nodeMap=graphMap[name],s=quad.subject.value,p=quad.predicate.value,o=quad.object;s in nodeMap||(nodeMap[s]={"@id":s});const node=nodeMap[s],objectIsNode=o.termType.endsWith("Node");if(objectIsNode&&!(o.value in nodeMap)&&(nodeMap[o.value]={"@id":o.value}),p===RDF_TYPE&&!useRdfType&&objectIsNode){_addValue(node,"@type",o.value,{propertyIsArray:!0});continue}const value=_RDFToObject(o,useNativeTypes,rdfDirection,options);if(_addValue(node,p,value,{propertyIsArray:!0}),objectIsNode)if(o.value===RDF_NIL){const object=nodeMap[o.value];"usages"in object||(object.usages=[]),object.usages.push({node,property:p,value})}else o.value in referencedOnce?referencedOnce[o.value]=!1:referencedOnce[o.value]={node,property:p,value}}for(const name in graphMap){const graphObject=graphMap[name];if(!(RDF_NIL in graphObject))continue;const nil=graphObject[RDF_NIL];if(nil.usages){for(let usage of nil.usages){let node=usage.node,property=usage.property,head=usage.value;const list=[],listNodes=[];let nodeKeyCount=Object.keys(node).length;for(;property===RDF_REST&&types.isObject(referencedOnce[node["@id"]])&&types.isArray(node[RDF_FIRST])&&1===node[RDF_FIRST].length&&types.isArray(node[RDF_REST])&&1===node[RDF_REST].length&&(3===nodeKeyCount||4===nodeKeyCount&&types.isArray(node["@type"])&&1===node["@type"].length&&node["@type"][0]===RDF_LIST)&&(list.push(node[RDF_FIRST][0]),listNodes.push(node["@id"]),usage=referencedOnce[node["@id"]],node=usage.node,property=usage.property,head=usage.value,nodeKeyCount=Object.keys(node).length,graphTypes.isBlankNode(node)););delete head["@id"],head["@list"]=list.reverse();for(const listNode of listNodes)delete graphObject[listNode]}delete nil.usages}}const result=[],subjects=Object.keys(defaultGraph).sort();for(const subject of subjects){const node=defaultGraph[subject];if(subject in graphMap){const graph=node["@graph"]=[],graphObject=graphMap[subject],graphSubjects=Object.keys(graphObject).sort();for(const graphSubject of graphSubjects){const node=graphObject[graphSubject];graphTypes.isSubjectReference(node)||graph.push(node)}}graphTypes.isSubjectReference(node)||result.push(node)}return result}},"./node_modules/jsonld/lib/graphTypes.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";const types=__webpack_require__("./node_modules/jsonld/lib/types.js"),api={};module.exports=api,api.isSubject=v=>{if(types.isObject(v)&&!("@value"in v||"@set"in v||"@list"in v)){return Object.keys(v).length>1||!("@id"in v)}return!1},api.isSubjectReference=v=>types.isObject(v)&&1===Object.keys(v).length&&"@id"in v,api.isValue=v=>types.isObject(v)&&"@value"in v,api.isList=v=>types.isObject(v)&&"@list"in v,api.isGraph=v=>types.isObject(v)&&"@graph"in v&&1===Object.keys(v).filter((key=>"@id"!==key&&"@index"!==key)).length,api.isSimpleGraph=v=>api.isGraph(v)&&!("@id"in v),api.isBlankNode=v=>{if(types.isObject(v)){if("@id"in v){const id=v["@id"];return!types.isString(id)||0===id.indexOf("_:")}return 0===Object.keys(v).length||!("@value"in v||"@set"in v||"@list"in v)}return!1}},"./node_modules/jsonld/lib/jsonld.js":(module,__unused_webpack_exports,__webpack_require__)=>{const canonize=__webpack_require__("./node_modules/rdf-canonize/index.js"),platform=__webpack_require__("./node_modules/jsonld/lib/platform-browser.js"),util=__webpack_require__("./node_modules/jsonld/lib/util.js"),ContextResolver=__webpack_require__("./node_modules/jsonld/lib/ContextResolver.js"),IdentifierIssuer=util.IdentifierIssuer,JsonLdError=__webpack_require__("./node_modules/jsonld/lib/JsonLdError.js"),LRU=__webpack_require__("./node_modules/jsonld/node_modules/lru-cache/index.js"),NQuads=__webpack_require__("./node_modules/jsonld/lib/NQuads.js"),{expand:_expand}=__webpack_require__("./node_modules/jsonld/lib/expand.js"),{flatten:_flatten}=__webpack_require__("./node_modules/jsonld/lib/flatten.js"),{fromRDF:_fromRDF}=__webpack_require__("./node_modules/jsonld/lib/fromRdf.js"),{toRDF:_toRDF}=__webpack_require__("./node_modules/jsonld/lib/toRdf.js"),{frameMergedOrDefault:_frameMergedOrDefault,cleanupNull:_cleanupNull}=__webpack_require__("./node_modules/jsonld/lib/frame.js"),{isArray:_isArray,isObject:_isObject,isString:_isString}=__webpack_require__("./node_modules/jsonld/lib/types.js"),{isSubjectReference:_isSubjectReference}=__webpack_require__("./node_modules/jsonld/lib/graphTypes.js"),{expandIri:_expandIri,getInitialContext:_getInitialContext,process:_processContext,processingMode:_processingMode}=__webpack_require__("./node_modules/jsonld/lib/context.js"),{compact:_compact,compactIri:_compactIri}=__webpack_require__("./node_modules/jsonld/lib/compact.js"),{createNodeMap:_createNodeMap,createMergedNodeMap:_createMergedNodeMap,mergeNodeMaps:_mergeNodeMaps}=__webpack_require__("./node_modules/jsonld/lib/nodeMap.js"),{logEventHandler:_logEventHandler,logWarningEventHandler:_logWarningEventHandler,safeEventHandler:_safeEventHandler,setDefaultEventHandler:_setDefaultEventHandler,setupEventHandler:_setupEventHandler,strictEventHandler:_strictEventHandler,unhandledEventHandler:_unhandledEventHandler}=__webpack_require__("./node_modules/jsonld/lib/events.js"),wrapper=function(jsonld){const _rdfParsers={},_resolvedContextCache=new LRU({max:100});function _setDefaults(options,{documentLoader=jsonld.documentLoader,...defaults}){if(options&&"compactionMap"in options)throw new JsonLdError('"compactionMap" not supported.',"jsonld.OptionsError");if(options&&"expansionMap"in options)throw new JsonLdError('"expansionMap" not supported.',"jsonld.OptionsError");return Object.assign({},{documentLoader},defaults,options,{eventHandler:_setupEventHandler({options})})}return jsonld.compact=async function(input,ctx,options){if(arguments.length<2)throw new TypeError("Could not compact, too few arguments.");if(null===ctx)throw new JsonLdError("The compaction context must not be null.","jsonld.CompactError",{code:"invalid local context"});if(null===input)return null;let expanded;(options=_setDefaults(options,{base:_isString(input)?input:"",compactArrays:!0,compactToRelative:!0,graph:!1,skipExpansion:!1,link:!1,issuer:new IdentifierIssuer("_:b"),contextResolver:new ContextResolver({sharedCache:_resolvedContextCache})})).link&&(options.skipExpansion=!0),options.compactToRelative||delete options.base,expanded=options.skipExpansion?input:await jsonld.expand(input,options);const activeCtx=await jsonld.processContext(_getInitialContext(options),ctx,options);let compacted=await _compact({activeCtx,element:expanded,options});options.compactArrays&&!options.graph&&_isArray(compacted)?1===compacted.length?compacted=compacted[0]:0===compacted.length&&(compacted={}):options.graph&&_isObject(compacted)&&(compacted=[compacted]),_isObject(ctx)&&"@context"in ctx&&(ctx=ctx["@context"]),ctx=util.clone(ctx),_isArray(ctx)||(ctx=[ctx]);const tmp=ctx;ctx=[];for(let i=0;i<tmp.length;++i)(!_isObject(tmp[i])||Object.keys(tmp[i]).length>0)&&ctx.push(tmp[i]);const hasContext=ctx.length>0;if(1===ctx.length&&(ctx=ctx[0]),_isArray(compacted)){const graphAlias=_compactIri({activeCtx,iri:"@graph",relativeTo:{vocab:!0}}),graph=compacted;compacted={},hasContext&&(compacted["@context"]=ctx),compacted[graphAlias]=graph}else if(_isObject(compacted)&&hasContext){const graph=compacted;compacted={"@context":ctx};for(const key in graph)compacted[key]=graph[key]}return compacted},jsonld.expand=async function(input,options){if(arguments.length<1)throw new TypeError("Could not expand, too few arguments.");const toResolve={},contextsToProcess=[];if("expandContext"in(options=_setDefaults(options,{keepFreeFloatingNodes:!1,contextResolver:new ContextResolver({sharedCache:_resolvedContextCache})}))){const expandContext=util.clone(options.expandContext);_isObject(expandContext)&&"@context"in expandContext?toResolve.expandContext=expandContext:toResolve.expandContext={"@context":expandContext},contextsToProcess.push(toResolve.expandContext)}let defaultBase;if(_isString(input)){const remoteDoc=await jsonld.get(input,options);defaultBase=remoteDoc.documentUrl,toResolve.input=remoteDoc.document,remoteDoc.contextUrl&&(toResolve.remoteContext={"@context":remoteDoc.contextUrl},contextsToProcess.push(toResolve.remoteContext))}else toResolve.input=util.clone(input);"base"in options||(options.base=defaultBase||"");let activeCtx=_getInitialContext(options);for(const localCtx of contextsToProcess)activeCtx=await _processContext({activeCtx,localCtx,options});let expanded=await _expand({activeCtx,element:toResolve.input,options});return _isObject(expanded)&&"@graph"in expanded&&1===Object.keys(expanded).length?expanded=expanded["@graph"]:null===expanded&&(expanded=[]),_isArray(expanded)||(expanded=[expanded]),expanded},jsonld.flatten=async function(input,ctx,options){if(arguments.length<1)return new TypeError("Could not flatten, too few arguments.");ctx="function"==typeof ctx?null:ctx||null,options=_setDefaults(options,{base:_isString(input)?input:"",contextResolver:new ContextResolver({sharedCache:_resolvedContextCache})});const expanded=await jsonld.expand(input,options),flattened=_flatten(expanded);if(null===ctx)return flattened;options.graph=!0,options.skipExpansion=!0;return await jsonld.compact(flattened,ctx,options)},jsonld.frame=async function(input,frame,options){if(arguments.length<2)throw new TypeError("Could not frame, too few arguments.");if(options=_setDefaults(options,{base:_isString(input)?input:"",embed:"@once",explicit:!1,requireAll:!1,omitDefault:!1,bnodesToClear:[],contextResolver:new ContextResolver({sharedCache:_resolvedContextCache})}),_isString(frame)){const remoteDoc=await jsonld.get(frame,options);if(frame=remoteDoc.document,remoteDoc.contextUrl){let ctx=frame["@context"];ctx?_isArray(ctx)?ctx.push(remoteDoc.contextUrl):ctx=[ctx,remoteDoc.contextUrl]:ctx=remoteDoc.contextUrl,frame["@context"]=ctx}}const frameContext=frame&&frame["@context"]||{},activeCtx=await jsonld.processContext(_getInitialContext(options),frameContext,options);options.hasOwnProperty("omitGraph")||(options.omitGraph=_processingMode(activeCtx,1.1)),options.hasOwnProperty("pruneBlankNodeIdentifiers")||(options.pruneBlankNodeIdentifiers=_processingMode(activeCtx,1.1));const expanded=await jsonld.expand(input,options),opts={...options};opts.isFrame=!0,opts.keepFreeFloatingNodes=!0;const expandedFrame=await jsonld.expand(frame,opts),frameKeys=Object.keys(frame).map((key=>_expandIri(activeCtx,key,{vocab:!0})));opts.merged=!frameKeys.includes("@graph"),opts.is11=_processingMode(activeCtx,1.1);const framed=_frameMergedOrDefault(expanded,expandedFrame,opts);opts.graph=!options.omitGraph,opts.skipExpansion=!0,opts.link={},opts.framing=!0;let compacted=await jsonld.compact(framed,frameContext,opts);return opts.link={},compacted=_cleanupNull(compacted,opts),compacted},jsonld.link=async function(input,ctx,options){const frame={};return ctx&&(frame["@context"]=ctx),frame["@embed"]="@link",jsonld.frame(input,frame,options)},jsonld.normalize=jsonld.canonize=async function(input,options){if(arguments.length<1)throw new TypeError("Could not canonize, too few arguments.");if("inputFormat"in(options=_setDefaults(options,{base:_isString(input)?input:null,algorithm:"URDNA2015",skipExpansion:!1,safe:!0,contextResolver:new ContextResolver({sharedCache:_resolvedContextCache})}))){if("application/n-quads"!==options.inputFormat&&"application/nquads"!==options.inputFormat)throw new JsonLdError("Unknown canonicalization input format.","jsonld.CanonizeError");const parsedInput=NQuads.parse(input);return canonize.canonize(parsedInput,options)}const opts={...options};delete opts.format,opts.produceGeneralizedRdf=!1;const dataset=await jsonld.toRDF(input,opts);return canonize.canonize(dataset,options)},jsonld.fromRDF=async function(dataset,options){if(arguments.length<1)throw new TypeError("Could not convert from RDF, too few arguments.");options=_setDefaults(options,{format:_isString(dataset)?"application/n-quads":void 0});const{format}=options;let{rdfParser}=options;if(format){if(rdfParser=rdfParser||_rdfParsers[format],!rdfParser)throw new JsonLdError("Unknown input format.","jsonld.UnknownFormat",{format})}else rdfParser=()=>dataset;const parsedDataset=await rdfParser(dataset);return _fromRDF(parsedDataset,options)},jsonld.toRDF=async function(input,options){if(arguments.length<1)throw new TypeError("Could not convert to RDF, too few arguments.");let expanded;expanded=(options=_setDefaults(options,{base:_isString(input)?input:"",skipExpansion:!1,contextResolver:new ContextResolver({sharedCache:_resolvedContextCache})})).skipExpansion?input:await jsonld.expand(input,options);const dataset=_toRDF(expanded,options);if(options.format){if("application/n-quads"===options.format||"application/nquads"===options.format)return NQuads.serialize(dataset);throw new JsonLdError("Unknown output format.","jsonld.UnknownFormat",{format:options.format})}return dataset},jsonld.createNodeMap=async function(input,options){if(arguments.length<1)throw new TypeError("Could not create node map, too few arguments.");options=_setDefaults(options,{base:_isString(input)?input:"",contextResolver:new ContextResolver({sharedCache:_resolvedContextCache})});const expanded=await jsonld.expand(input,options);return _createMergedNodeMap(expanded,options)},jsonld.merge=async function(docs,ctx,options){if(arguments.length<1)throw new TypeError("Could not merge, too few arguments.");if(!_isArray(docs))throw new TypeError('Could not merge, "docs" must be an array.');ctx="function"==typeof ctx?null:ctx||null,options=_setDefaults(options,{contextResolver:new ContextResolver({sharedCache:_resolvedContextCache})});const expanded=await Promise.all(docs.map((doc=>{const opts={...options};return jsonld.expand(doc,opts)})));let mergeNodes=!0;"mergeNodes"in options&&(mergeNodes=options.mergeNodes);const issuer=options.issuer||new IdentifierIssuer("_:b"),graphs={"@default":{}};for(let i=0;i<expanded.length;++i){const doc=util.relabelBlankNodes(expanded[i],{issuer:new IdentifierIssuer("_:b"+i+"-")}),_graphs=mergeNodes||0===i?graphs:{"@default":{}};if(_createNodeMap(doc,_graphs,"@default",issuer),_graphs!==graphs)for(const graphName in _graphs){const _nodeMap=_graphs[graphName];if(!(graphName in graphs)){graphs[graphName]=_nodeMap;continue}const nodeMap=graphs[graphName];for(const key in _nodeMap)key in nodeMap||(nodeMap[key]=_nodeMap[key])}}const defaultGraph=_mergeNodeMaps(graphs),flattened=[],keys=Object.keys(defaultGraph).sort();for(let ki=0;ki<keys.length;++ki){const node=defaultGraph[keys[ki]];_isSubjectReference(node)||flattened.push(node)}if(null===ctx)return flattened;options.graph=!0,options.skipExpansion=!0;return await jsonld.compact(flattened,ctx,options)},Object.defineProperty(jsonld,"documentLoader",{get:()=>jsonld._documentLoader,set:v=>jsonld._documentLoader=v}),jsonld.documentLoader=async url=>{throw new JsonLdError("Could not retrieve a JSON-LD document from the URL. URL dereferencing not implemented.","jsonld.LoadDocumentError",{code:"loading document failed",url})},jsonld.get=async function(url,options){let load;load="function"==typeof options.documentLoader?options.documentLoader:jsonld.documentLoader;const remoteDoc=await load(url);try{if(!remoteDoc.document)throw new JsonLdError("No remote document found at the given URL.","jsonld.NullRemoteDocument");_isString(remoteDoc.document)&&(remoteDoc.document=JSON.parse(remoteDoc.document))}catch(e){throw new JsonLdError("Could not retrieve a JSON-LD document from the URL.","jsonld.LoadDocumentError",{code:"loading document failed",cause:e,remoteDoc})}return remoteDoc},jsonld.processContext=async function(activeCtx,localCtx,options){return options=_setDefaults(options,{base:"",contextResolver:new ContextResolver({sharedCache:_resolvedContextCache})}),null===localCtx?_getInitialContext(options):(localCtx=util.clone(localCtx),_isObject(localCtx)&&"@context"in localCtx||(localCtx={"@context":localCtx}),_processContext({activeCtx,localCtx,options}))},jsonld.getContextValue=__webpack_require__("./node_modules/jsonld/lib/context.js").getContextValue,jsonld.documentLoaders={},jsonld.useDocumentLoader=function(type){if(!(type in jsonld.documentLoaders))throw new JsonLdError('Unknown document loader type: "'+type+'"',"jsonld.UnknownDocumentLoader",{type});jsonld.documentLoader=jsonld.documentLoaders[type].apply(jsonld,Array.prototype.slice.call(arguments,1))},jsonld.registerRDFParser=function(contentType,parser){_rdfParsers[contentType]=parser},jsonld.unregisterRDFParser=function(contentType){delete _rdfParsers[contentType]},jsonld.registerRDFParser("application/n-quads",NQuads.parse),jsonld.registerRDFParser("application/nquads",NQuads.parse),jsonld.url=__webpack_require__("./node_modules/jsonld/lib/url.js"),jsonld.logEventHandler=_logEventHandler,jsonld.logWarningEventHandler=_logWarningEventHandler,jsonld.safeEventHandler=_safeEventHandler,jsonld.setDefaultEventHandler=_setDefaultEventHandler,jsonld.strictEventHandler=_strictEventHandler,jsonld.unhandledEventHandler=_unhandledEventHandler,jsonld.util=util,Object.assign(jsonld,util),jsonld.promises=jsonld,jsonld.RequestQueue=__webpack_require__("./node_modules/jsonld/lib/RequestQueue.js"),jsonld.JsonLdProcessor=__webpack_require__("./node_modules/jsonld/lib/JsonLdProcessor.js")(jsonld),platform.setupGlobals(jsonld),platform.setupDocumentLoaders(jsonld),jsonld},factory=function(){return wrapper((function(){return factory()}))};wrapper(factory),module.exports=factory},"./node_modules/jsonld/lib/nodeMap.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";const{isKeyword}=__webpack_require__("./node_modules/jsonld/lib/context.js"),graphTypes=__webpack_require__("./node_modules/jsonld/lib/graphTypes.js"),types=__webpack_require__("./node_modules/jsonld/lib/types.js"),util=__webpack_require__("./node_modules/jsonld/lib/util.js"),JsonLdError=__webpack_require__("./node_modules/jsonld/lib/JsonLdError.js"),api={};module.exports=api,api.createMergedNodeMap=(input,options)=>{const issuer=(options=options||{}).issuer||new util.IdentifierIssuer("_:b"),graphs={"@default":{}};return api.createNodeMap(input,graphs,"@default",issuer),api.mergeNodeMaps(graphs)},api.createNodeMap=(input,graphs,graph,issuer,name,list)=>{if(types.isArray(input)){for(const node of input)api.createNodeMap(node,graphs,graph,issuer,void 0,list);return}if(!types.isObject(input))return void(list&&list.push(input));if(graphTypes.isValue(input)){if("@type"in input){let type=input["@type"];0===type.indexOf("_:")&&(input["@type"]=type=issuer.getId(type))}return void(list&&list.push(input))}if(list&&graphTypes.isList(input)){const _list=[];return api.createNodeMap(input["@list"],graphs,graph,issuer,name,_list),void list.push({"@list":_list})}if("@type"in input){const types=input["@type"];for(const type of types)0===type.indexOf("_:")&&issuer.getId(type)}types.isUndefined(name)&&(name=graphTypes.isBlankNode(input)?issuer.getId(input["@id"]):input["@id"]),list&&list.push({"@id":name});const subjects=graphs[graph],subject=subjects[name]=subjects[name]||{};subject["@id"]=name;const properties=Object.keys(input).sort();for(let property of properties){if("@id"===property)continue;if("@reverse"===property){const referencedNode={"@id":name},reverseMap=input["@reverse"];for(const reverseProperty in reverseMap){const items=reverseMap[reverseProperty];for(const item of items){let itemName=item["@id"];graphTypes.isBlankNode(item)&&(itemName=issuer.getId(itemName)),api.createNodeMap(item,graphs,graph,issuer,itemName),util.addValue(subjects[itemName],reverseProperty,referencedNode,{propertyIsArray:!0,allowDuplicate:!1})}}continue}if("@graph"===property){name in graphs||(graphs[name]={}),api.createNodeMap(input[property],graphs,name,issuer);continue}if("@included"===property){api.createNodeMap(input[property],graphs,graph,issuer);continue}if("@type"!==property&&isKeyword(property)){if("@index"===property&&property in subject&&(input[property]!==subject[property]||input[property]["@id"]!==subject[property]["@id"]))throw new JsonLdError("Invalid JSON-LD syntax; conflicting @index property detected.","jsonld.SyntaxError",{code:"conflicting indexes",subject});subject[property]=input[property];continue}const objects=input[property];if(0===property.indexOf("_:")&&(property=issuer.getId(property)),0!==objects.length)for(let o of objects)if("@type"===property&&(o=0===o.indexOf("_:")?issuer.getId(o):o),graphTypes.isSubject(o)||graphTypes.isSubjectReference(o)){if("@id"in o&&!o["@id"])continue;const id=graphTypes.isBlankNode(o)?issuer.getId(o["@id"]):o["@id"];util.addValue(subject,property,{"@id":id},{propertyIsArray:!0,allowDuplicate:!1}),api.createNodeMap(o,graphs,graph,issuer,id)}else if(graphTypes.isValue(o))util.addValue(subject,property,o,{propertyIsArray:!0,allowDuplicate:!1});else if(graphTypes.isList(o)){const _list=[];api.createNodeMap(o["@list"],graphs,graph,issuer,name,_list),o={"@list":_list},util.addValue(subject,property,o,{propertyIsArray:!0,allowDuplicate:!1})}else api.createNodeMap(o,graphs,graph,issuer,name),util.addValue(subject,property,o,{propertyIsArray:!0,allowDuplicate:!1});else util.addValue(subject,property,[],{propertyIsArray:!0})}},api.mergeNodeMapGraphs=graphs=>{const merged={};for(const name of Object.keys(graphs).sort())for(const id of Object.keys(graphs[name]).sort()){const node=graphs[name][id];id in merged||(merged[id]={"@id":id});const mergedNode=merged[id];for(const property of Object.keys(node).sort())if(isKeyword(property)&&"@type"!==property)mergedNode[property]=util.clone(node[property]);else for(const value of node[property])util.addValue(mergedNode,property,util.clone(value),{propertyIsArray:!0,allowDuplicate:!1})}return merged},api.mergeNodeMaps=graphs=>{const defaultGraph=graphs["@default"],graphNames=Object.keys(graphs).sort();for(const graphName of graphNames){if("@default"===graphName)continue;const nodeMap=graphs[graphName];let subject=defaultGraph[graphName];subject?"@graph"in subject||(subject["@graph"]=[]):defaultGraph[graphName]=subject={"@id":graphName,"@graph":[]};const graph=subject["@graph"];for(const id of Object.keys(nodeMap).sort()){const node=nodeMap[id];graphTypes.isSubjectReference(node)||graph.push(node)}}return defaultGraph}},"./node_modules/jsonld/lib/platform-browser.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";const xhrLoader=__webpack_require__("./node_modules/jsonld/lib/documentLoaders/xhr.js"),api={};module.exports=api,api.setupDocumentLoaders=function(jsonld){"undefined"!=typeof XMLHttpRequest&&(jsonld.documentLoaders.xhr=xhrLoader,jsonld.useDocumentLoader("xhr"))},api.setupGlobals=function(jsonld){void 0===globalThis.JsonLdProcessor&&Object.defineProperty(globalThis,"JsonLdProcessor",{writable:!0,enumerable:!1,configurable:!0,value:jsonld.JsonLdProcessor})}},"./node_modules/jsonld/lib/toRdf.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";const{createNodeMap}=__webpack_require__("./node_modules/jsonld/lib/nodeMap.js"),{isKeyword}=__webpack_require__("./node_modules/jsonld/lib/context.js"),graphTypes=__webpack_require__("./node_modules/jsonld/lib/graphTypes.js"),jsonCanonicalize=__webpack_require__("./node_modules/canonicalize/lib/canonicalize.js"),JsonLdError=__webpack_require__("./node_modules/jsonld/lib/JsonLdError.js"),types=__webpack_require__("./node_modules/jsonld/lib/types.js"),util=__webpack_require__("./node_modules/jsonld/lib/util.js"),{handleEvent:_handleEvent}=__webpack_require__("./node_modules/jsonld/lib/events.js"),{RDF_FIRST,RDF_REST,RDF_NIL,RDF_TYPE,RDF_JSON_LITERAL,RDF_LANGSTRING,XSD_BOOLEAN,XSD_DOUBLE,XSD_INTEGER,XSD_STRING}=__webpack_require__("./node_modules/jsonld/lib/constants.js"),{isAbsolute:_isAbsoluteIri}=__webpack_require__("./node_modules/jsonld/lib/url.js"),api={};function _graphToRDF(dataset,graph,graphTerm,issuer,options){const ids=Object.keys(graph).sort();for(const id of ids){const node=graph[id],properties=Object.keys(node).sort();for(let property of properties){const items=node[property];if("@type"===property)property=RDF_TYPE;else if(isKeyword(property))continue;for(const item of items){const subject={termType:id.startsWith("_:")?"BlankNode":"NamedNode",value:id};if(!_isAbsoluteIri(id)){options.eventHandler&&_handleEvent({event:{type:["JsonLdEvent"],code:"relative subject reference",level:"warning",message:"Relative subject reference found.",details:{subject:id}},options});continue}const predicate={termType:property.startsWith("_:")?"BlankNode":"NamedNode",value:property};if(!_isAbsoluteIri(property)){options.eventHandler&&_handleEvent({event:{type:["JsonLdEvent"],code:"relative predicate reference",level:"warning",message:"Relative predicate reference found.",details:{predicate:property}},options});continue}if("BlankNode"===predicate.termType&&!options.produceGeneralizedRdf){options.eventHandler&&_handleEvent({event:{type:["JsonLdEvent"],code:"blank node predicate",level:"warning",message:"Dropping blank node predicate.",details:{property:issuer.getOldIds().find((key=>issuer.getId(key)===property))}},options});continue}const object=_objectToRDF(item,issuer,dataset,graphTerm,options.rdfDirection,options);object&&dataset.push({subject,predicate,object,graph:graphTerm})}}}}function _objectToRDF(item,issuer,dataset,graphTerm,rdfDirection,options){const object={};if(graphTypes.isValue(item)){object.termType="Literal",object.value=void 0,object.datatype={termType:"NamedNode"};let value=item["@value"];const datatype=item["@type"]||null;if("@json"===datatype)object.value=jsonCanonicalize(value),object.datatype.value=RDF_JSON_LITERAL;else if(types.isBoolean(value))object.value=value.toString(),object.datatype.value=datatype||XSD_BOOLEAN;else if(types.isDouble(value)||datatype===XSD_DOUBLE)types.isDouble(value)||(value=parseFloat(value)),object.value=value.toExponential(15).replace(/(\d)0*e\+?/,"$1E"),object.datatype.value=datatype||XSD_DOUBLE;else if(types.isNumber(value))object.value=value.toFixed(0),object.datatype.value=datatype||XSD_INTEGER;else if("@direction"in item&&"i18n-datatype"===rdfDirection){const datatype=`https://www.w3.org/ns/i18n#${(item["@language"]||"").toLowerCase()}_${item["@direction"]}`;object.datatype.value=datatype,object.value=value}else{if("@direction"in item&&"compound-literal"===rdfDirection)throw new JsonLdError("Unsupported rdfDirection value.","jsonld.InvalidRdfDirection",{value:rdfDirection});if("@direction"in item&&rdfDirection)throw new JsonLdError("Unknown rdfDirection value.","jsonld.InvalidRdfDirection",{value:rdfDirection});"@language"in item?("@direction"in item&&!rdfDirection&&options.eventHandler&&_handleEvent({event:{type:["JsonLdEvent"],code:"rdfDirection not set",level:"warning",message:"rdfDirection not set for @direction.",details:{object:object.value}},options}),object.value=value,object.datatype.value=datatype||RDF_LANGSTRING,object.language=item["@language"]):("@direction"in item&&!rdfDirection&&options.eventHandler&&_handleEvent({event:{type:["JsonLdEvent"],code:"rdfDirection not set",level:"warning",message:"rdfDirection not set for @direction.",details:{object:object.value}},options}),object.value=value,object.datatype.value=datatype||XSD_STRING)}}else if(graphTypes.isList(item)){const _list=function _listToRDF(list,issuer,dataset,graphTerm,rdfDirection,options){const first={termType:"NamedNode",value:RDF_FIRST},rest={termType:"NamedNode",value:RDF_REST},nil={termType:"NamedNode",value:RDF_NIL},last=list.pop(),result=last?{termType:"BlankNode",value:issuer.getId()}:nil;let subject=result;for(const item of list){const object=_objectToRDF(item,issuer,dataset,graphTerm,rdfDirection,options),next={termType:"BlankNode",value:issuer.getId()};dataset.push({subject,predicate:first,object,graph:graphTerm}),dataset.push({subject,predicate:rest,object:next,graph:graphTerm}),subject=next}if(last){const object=_objectToRDF(last,issuer,dataset,graphTerm,rdfDirection,options);dataset.push({subject,predicate:first,object,graph:graphTerm}),dataset.push({subject,predicate:rest,object:nil,graph:graphTerm})}return result}(item["@list"],issuer,dataset,graphTerm,rdfDirection,options);object.termType=_list.termType,object.value=_list.value}else{const id=types.isObject(item)?item["@id"]:item;object.termType=id.startsWith("_:")?"BlankNode":"NamedNode",object.value=id}return"NamedNode"!==object.termType||_isAbsoluteIri(object.value)?object:(options.eventHandler&&_handleEvent({event:{type:["JsonLdEvent"],code:"relative object reference",level:"warning",message:"Relative object reference found.",details:{object:object.value}},options}),null)}module.exports=api,api.toRDF=(input,options)=>{const issuer=new util.IdentifierIssuer("_:b"),nodeMap={"@default":{}};createNodeMap(input,nodeMap,"@default",issuer);const dataset=[],graphNames=Object.keys(nodeMap).sort();for(const graphName of graphNames){let graphTerm;if("@default"===graphName)graphTerm={termType:"DefaultGraph",value:""};else{if(!_isAbsoluteIri(graphName)){options.eventHandler&&_handleEvent({event:{type:["JsonLdEvent"],code:"relative graph reference",level:"warning",message:"Relative graph reference found.",details:{graph:graphName}},options});continue}graphTerm=graphName.startsWith("_:")?{termType:"BlankNode"}:{termType:"NamedNode"},graphTerm.value=graphName}_graphToRDF(dataset,nodeMap[graphName],graphTerm,issuer,options)}return dataset}},"./node_modules/jsonld/lib/types.js":module=>{"use strict";const api={};module.exports=api,api.isArray=Array.isArray,api.isBoolean=v=>"boolean"==typeof v||"[object Boolean]"===Object.prototype.toString.call(v),api.isDouble=v=>api.isNumber(v)&&(-1!==String(v).indexOf(".")||Math.abs(v)>=1e21),api.isEmptyObject=v=>api.isObject(v)&&0===Object.keys(v).length,api.isNumber=v=>"number"==typeof v||"[object Number]"===Object.prototype.toString.call(v),api.isNumeric=v=>!isNaN(parseFloat(v))&&isFinite(v),api.isObject=v=>"[object Object]"===Object.prototype.toString.call(v),api.isString=v=>"string"==typeof v||"[object String]"===Object.prototype.toString.call(v),api.isUndefined=v=>void 0===v},"./node_modules/jsonld/lib/url.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";const types=__webpack_require__("./node_modules/jsonld/lib/types.js"),api={};module.exports=api,api.parsers={simple:{keys:["href","scheme","authority","path","query","fragment"],regex:/^(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/},full:{keys:["href","protocol","scheme","authority","auth","user","password","hostname","port","path","directory","file","query","fragment"],regex:/^(([a-zA-Z][a-zA-Z0-9+-.]*):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?(?:(((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/}},api.parse=(str,parser)=>{const parsed={},o=api.parsers[parser||"full"],m=o.regex.exec(str);let i=o.keys.length;for(;i--;)parsed[o.keys[i]]=void 0===m[i]?null:m[i];return("https"===parsed.scheme&&"443"===parsed.port||"http"===parsed.scheme&&"80"===parsed.port)&&(parsed.href=parsed.href.replace(":"+parsed.port,""),parsed.authority=parsed.authority.replace(":"+parsed.port,""),parsed.port=null),parsed.normalizedPath=api.removeDotSegments(parsed.path),parsed},api.prependBase=(base,iri)=>{if(null===base)return iri;if(api.isAbsolute(iri))return iri;base&&!types.isString(base)||(base=api.parse(base||""));const rel=api.parse(iri),transform={protocol:base.protocol||""};if(null!==rel.authority)transform.authority=rel.authority,transform.path=rel.path,transform.query=rel.query;else if(transform.authority=base.authority,""===rel.path)transform.path=base.path,null!==rel.query?transform.query=rel.query:transform.query=base.query;else{if(0===rel.path.indexOf("/"))transform.path=rel.path;else{let path=base.path;path=path.substr(0,path.lastIndexOf("/")+1),(path.length>0||base.authority)&&"/"!==path.substr(-1)&&(path+="/"),path+=rel.path,transform.path=path}transform.query=rel.query}""!==rel.path&&(transform.path=api.removeDotSegments(transform.path));let rval=transform.protocol;return null!==transform.authority&&(rval+="//"+transform.authority),rval+=transform.path,null!==transform.query&&(rval+="?"+transform.query),null!==rel.fragment&&(rval+="#"+rel.fragment),""===rval&&(rval="./"),rval},api.removeBase=(base,iri)=>{if(null===base)return iri;base&&!types.isString(base)||(base=api.parse(base||""));let root="";if(""!==base.href?root+=(base.protocol||"")+"//"+(base.authority||""):iri.indexOf("//")&&(root+="//"),0!==iri.indexOf(root))return iri;const rel=api.parse(iri.substr(root.length)),baseSegments=base.normalizedPath.split("/"),iriSegments=rel.normalizedPath.split("/"),last=rel.fragment||rel.query?0:1;for(;baseSegments.length>0&&iriSegments.length>last&&baseSegments[0]===iriSegments[0];)baseSegments.shift(),iriSegments.shift();let rval="";if(baseSegments.length>0){baseSegments.pop();for(let i=0;i<baseSegments.length;++i)rval+="../"}return rval+=iriSegments.join("/"),null!==rel.query&&(rval+="?"+rel.query),null!==rel.fragment&&(rval+="#"+rel.fragment),""===rval&&(rval="./"),rval},api.removeDotSegments=path=>{if(0===path.length)return"";const input=path.split("/"),output=[];for(;input.length>0;){const next=input.shift(),done=0===input.length;"."!==next?".."!==next?output.push(next):(output.pop(),done&&output.push("")):done&&output.push("")}return"/"===path[0]&&output.length>0&&""!==output[0]&&output.unshift(""),1===output.length&&""===output[0]?"/":output.join("/")};const isAbsoluteRegex=/^([A-Za-z][A-Za-z0-9+-.]*|_):[^\s]*$/;api.isAbsolute=v=>types.isString(v)&&isAbsoluteRegex.test(v),api.isRelative=v=>types.isString(v)},"./node_modules/jsonld/lib/util.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";const graphTypes=__webpack_require__("./node_modules/jsonld/lib/graphTypes.js"),types=__webpack_require__("./node_modules/jsonld/lib/types.js"),IdentifierIssuer=__webpack_require__("./node_modules/rdf-canonize/index.js").IdentifierIssuer,JsonLdError=__webpack_require__("./node_modules/jsonld/lib/JsonLdError.js"),REGEX_LINK_HEADERS=/(?:<[^>]*?>|"[^"]*?"|[^,])+/g,REGEX_LINK_HEADER=/\s*<([^>]*?)>\s*(?:;\s*(.*))?/,REGEX_LINK_HEADER_PARAMS=/(.*?)=(?:(?:"([^"]*?)")|([^"]*?))\s*(?:(?:;\s*)|$)/g,DEFAULTS_headers={accept:"application/ld+json, application/json"},api={};function _labelBlankNodes(issuer,element){if(types.isArray(element))for(let i=0;i<element.length;++i)element[i]=_labelBlankNodes(issuer,element[i]);else if(graphTypes.isList(element))element["@list"]=_labelBlankNodes(issuer,element["@list"]);else if(types.isObject(element)){graphTypes.isBlankNode(element)&&(element["@id"]=issuer.getId(element["@id"]));const keys=Object.keys(element).sort();for(let ki=0;ki<keys.length;++ki){const key=keys[ki];"@id"!==key&&(element[key]=_labelBlankNodes(issuer,element[key]))}}return element}module.exports=api,api.IdentifierIssuer=IdentifierIssuer,api.REGEX_BCP47=/^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/,api.REGEX_KEYWORD=/^@[a-zA-Z]+$/,api.clone=function(value){if(value&&"object"==typeof value){let rval;if(types.isArray(value)){rval=[];for(let i=0;i<value.length;++i)rval[i]=api.clone(value[i])}else if(value instanceof Map){rval=new Map;for(const[k,v]of value)rval.set(k,api.clone(v))}else if(value instanceof Set){rval=new Set;for(const v of value)rval.add(api.clone(v))}else if(types.isObject(value)){rval={};for(const key in value)rval[key]=api.clone(value[key])}else rval=value.toString();return rval}return value},api.asArray=function(value){return Array.isArray(value)?value:[value]},api.buildHeaders=(headers={})=>{if(Object.keys(headers).some((h=>"accept"===h.toLowerCase())))throw new RangeError('Accept header may not be specified; only "'+DEFAULTS_headers.accept+'" is supported.');return Object.assign({Accept:DEFAULTS_headers.accept},headers)},api.parseLinkHeader=header=>{const rval={},entries=header.match(REGEX_LINK_HEADERS);for(let i=0;i<entries.length;++i){let match=entries[i].match(REGEX_LINK_HEADER);if(!match)continue;const result={target:match[1]},params=match[2];for(;match=REGEX_LINK_HEADER_PARAMS.exec(params);)result[match[1]]=void 0===match[2]?match[3]:match[2];const rel=result.rel||"";Array.isArray(rval[rel])?rval[rel].push(result):rval.hasOwnProperty(rel)?rval[rel]=[rval[rel],result]:rval[rel]=result}return rval},api.validateTypeValue=(v,isFrame)=>{if(!(types.isString(v)||types.isArray(v)&&v.every((vv=>types.isString(vv))))){if(isFrame&&types.isObject(v))switch(Object.keys(v).length){case 0:return;case 1:if("@default"in v&&api.asArray(v["@default"]).every((vv=>types.isString(vv))))return}throw new JsonLdError('Invalid JSON-LD syntax; "@type" value must a string, an array of strings, an empty object, or a default object.',"jsonld.SyntaxError",{code:"invalid type value",value:v})}},api.hasProperty=(subject,property)=>{if(subject.hasOwnProperty(property)){const value=subject[property];return!types.isArray(value)||value.length>0}return!1},api.hasValue=(subject,property,value)=>{if(api.hasProperty(subject,property)){let val=subject[property];const isList=graphTypes.isList(val);if(types.isArray(val)||isList){isList&&(val=val["@list"]);for(let i=0;i<val.length;++i)if(api.compareValues(value,val[i]))return!0}else if(!types.isArray(value))return api.compareValues(value,val)}return!1},api.addValue=(subject,property,value,options)=>{if("propertyIsArray"in(options=options||{})||(options.propertyIsArray=!1),"valueIsArray"in options||(options.valueIsArray=!1),"allowDuplicate"in options||(options.allowDuplicate=!0),"prependValue"in options||(options.prependValue=!1),options.valueIsArray)subject[property]=value;else if(types.isArray(value)){0===value.length&&options.propertyIsArray&&!subject.hasOwnProperty(property)&&(subject[property]=[]),options.prependValue&&(value=value.concat(subject[property]),subject[property]=[]);for(let i=0;i<value.length;++i)api.addValue(subject,property,value[i],options)}else if(subject.hasOwnProperty(property)){const hasValue=!options.allowDuplicate&&api.hasValue(subject,property,value);types.isArray(subject[property])||hasValue&&!options.propertyIsArray||(subject[property]=[subject[property]]),hasValue||(options.prependValue?subject[property].unshift(value):subject[property].push(value))}else subject[property]=options.propertyIsArray?[value]:value},api.getValues=(subject,property)=>[].concat(subject[property]||[]),api.removeProperty=(subject,property)=>{delete subject[property]},api.removeValue=(subject,property,value,options)=>{"propertyIsArray"in(options=options||{})||(options.propertyIsArray=!1);const values=api.getValues(subject,property).filter((e=>!api.compareValues(e,value)));0===values.length?api.removeProperty(subject,property):1!==values.length||options.propertyIsArray?subject[property]=values:subject[property]=values[0]},api.relabelBlankNodes=(input,options)=>_labelBlankNodes((options=options||{}).issuer||new IdentifierIssuer("_:b"),input),api.compareValues=(v1,v2)=>v1===v2||(!(!graphTypes.isValue(v1)||!graphTypes.isValue(v2)||v1["@value"]!==v2["@value"]||v1["@type"]!==v2["@type"]||v1["@language"]!==v2["@language"]||v1["@index"]!==v2["@index"])||!!(types.isObject(v1)&&"@id"in v1&&types.isObject(v2)&&"@id"in v2)&&v1["@id"]===v2["@id"]),api.compareShortestLeast=(a,b)=>a.length<b.length?-1:b.length<a.length?1:a===b?0:a<b?-1:1},"./node_modules/jsonld/node_modules/lru-cache/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";const Yallist=__webpack_require__("./node_modules/jsonld/node_modules/yallist/yallist.js"),MAX=Symbol("max"),LENGTH=Symbol("length"),LENGTH_CALCULATOR=Symbol("lengthCalculator"),ALLOW_STALE=Symbol("allowStale"),MAX_AGE=Symbol("maxAge"),DISPOSE=Symbol("dispose"),NO_DISPOSE_ON_SET=Symbol("noDisposeOnSet"),LRU_LIST=Symbol("lruList"),CACHE=Symbol("cache"),UPDATE_AGE_ON_GET=Symbol("updateAgeOnGet"),naiveLength=()=>1;const get=(self,key,doUse)=>{const node=self[CACHE].get(key);if(node){const hit=node.value;if(isStale(self,hit)){if(del(self,node),!self[ALLOW_STALE])return}else doUse&&(self[UPDATE_AGE_ON_GET]&&(node.value.now=Date.now()),self[LRU_LIST].unshiftNode(node));return hit.value}},isStale=(self,hit)=>{if(!hit||!hit.maxAge&&!self[MAX_AGE])return!1;const diff=Date.now()-hit.now;return hit.maxAge?diff>hit.maxAge:self[MAX_AGE]&&diff>self[MAX_AGE]},trim=self=>{if(self[LENGTH]>self[MAX])for(let walker=self[LRU_LIST].tail;self[LENGTH]>self[MAX]&&null!==walker;){const prev=walker.prev;del(self,walker),walker=prev}},del=(self,node)=>{if(node){const hit=node.value;self[DISPOSE]&&self[DISPOSE](hit.key,hit.value),self[LENGTH]-=hit.length,self[CACHE].delete(hit.key),self[LRU_LIST].removeNode(node)}};class Entry{constructor(key,value,length,now,maxAge){this.key=key,this.value=value,this.length=length,this.now=now,this.maxAge=maxAge||0}}const forEachStep=(self,fn,node,thisp)=>{let hit=node.value;isStale(self,hit)&&(del(self,node),self[ALLOW_STALE]||(hit=void 0)),hit&&fn.call(thisp,hit.value,hit.key,self)};module.exports=class LRUCache{constructor(options){if("number"==typeof options&&(options={max:options}),options||(options={}),options.max&&("number"!=typeof options.max||options.max<0))throw new TypeError("max must be a non-negative number");this[MAX]=options.max||1/0;const lc=options.length||naiveLength;if(this[LENGTH_CALCULATOR]="function"!=typeof lc?naiveLength:lc,this[ALLOW_STALE]=options.stale||!1,options.maxAge&&"number"!=typeof options.maxAge)throw new TypeError("maxAge must be a number");this[MAX_AGE]=options.maxAge||0,this[DISPOSE]=options.dispose,this[NO_DISPOSE_ON_SET]=options.noDisposeOnSet||!1,this[UPDATE_AGE_ON_GET]=options.updateAgeOnGet||!1,this.reset()}set max(mL){if("number"!=typeof mL||mL<0)throw new TypeError("max must be a non-negative number");this[MAX]=mL||1/0,trim(this)}get max(){return this[MAX]}set allowStale(allowStale){this[ALLOW_STALE]=!!allowStale}get allowStale(){return this[ALLOW_STALE]}set maxAge(mA){if("number"!=typeof mA)throw new TypeError("maxAge must be a non-negative number");this[MAX_AGE]=mA,trim(this)}get maxAge(){return this[MAX_AGE]}set lengthCalculator(lC){"function"!=typeof lC&&(lC=naiveLength),lC!==this[LENGTH_CALCULATOR]&&(this[LENGTH_CALCULATOR]=lC,this[LENGTH]=0,this[LRU_LIST].forEach((hit=>{hit.length=this[LENGTH_CALCULATOR](hit.value,hit.key),this[LENGTH]+=hit.length}))),trim(this)}get lengthCalculator(){return this[LENGTH_CALCULATOR]}get length(){return this[LENGTH]}get itemCount(){return this[LRU_LIST].length}rforEach(fn,thisp){thisp=thisp||this;for(let walker=this[LRU_LIST].tail;null!==walker;){const prev=walker.prev;forEachStep(this,fn,walker,thisp),walker=prev}}forEach(fn,thisp){thisp=thisp||this;for(let walker=this[LRU_LIST].head;null!==walker;){const next=walker.next;forEachStep(this,fn,walker,thisp),walker=next}}keys(){return this[LRU_LIST].toArray().map((k=>k.key))}values(){return this[LRU_LIST].toArray().map((k=>k.value))}reset(){this[DISPOSE]&&this[LRU_LIST]&&this[LRU_LIST].length&&this[LRU_LIST].forEach((hit=>this[DISPOSE](hit.key,hit.value))),this[CACHE]=new Map,this[LRU_LIST]=new Yallist,this[LENGTH]=0}dump(){return this[LRU_LIST].map((hit=>!isStale(this,hit)&&{k:hit.key,v:hit.value,e:hit.now+(hit.maxAge||0)})).toArray().filter((h=>h))}dumpLru(){return this[LRU_LIST]}set(key,value,maxAge){if((maxAge=maxAge||this[MAX_AGE])&&"number"!=typeof maxAge)throw new TypeError("maxAge must be a number");const now=maxAge?Date.now():0,len=this[LENGTH_CALCULATOR](value,key);if(this[CACHE].has(key)){if(len>this[MAX])return del(this,this[CACHE].get(key)),!1;const item=this[CACHE].get(key).value;return this[DISPOSE]&&(this[NO_DISPOSE_ON_SET]||this[DISPOSE](key,item.value)),item.now=now,item.maxAge=maxAge,item.value=value,this[LENGTH]+=len-item.length,item.length=len,this.get(key),trim(this),!0}const hit=new Entry(key,value,len,now,maxAge);return hit.length>this[MAX]?(this[DISPOSE]&&this[DISPOSE](key,value),!1):(this[LENGTH]+=hit.length,this[LRU_LIST].unshift(hit),this[CACHE].set(key,this[LRU_LIST].head),trim(this),!0)}has(key){if(!this[CACHE].has(key))return!1;const hit=this[CACHE].get(key).value;return!isStale(this,hit)}get(key){return get(this,key,!0)}peek(key){return get(this,key,!1)}pop(){const node=this[LRU_LIST].tail;return node?(del(this,node),node.value):null}del(key){del(this,this[CACHE].get(key))}load(arr){this.reset();const now=Date.now();for(let l=arr.length-1;l>=0;l--){const hit=arr[l],expiresAt=hit.e||0;if(0===expiresAt)this.set(hit.k,hit.v);else{const maxAge=expiresAt-now;maxAge>0&&this.set(hit.k,hit.v,maxAge)}}}prune(){this[CACHE].forEach(((value,key)=>get(this,key,!1)))}}},"./node_modules/jsonld/node_modules/yallist/iterator.js":module=>{"use strict";module.exports=function(Yallist){Yallist.prototype[Symbol.iterator]=function*(){for(let walker=this.head;walker;walker=walker.next)yield walker.value}}},"./node_modules/jsonld/node_modules/yallist/yallist.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";function Yallist(list){var self=this;if(self instanceof Yallist||(self=new Yallist),self.tail=null,self.head=null,self.length=0,list&&"function"==typeof list.forEach)list.forEach((function(item){self.push(item)}));else if(arguments.length>0)for(var i=0,l=arguments.length;i<l;i++)self.push(arguments[i]);return self}function insert(self,node,value){var inserted=node===self.head?new Node(value,null,node,self):new Node(value,node,node.next,self);return null===inserted.next&&(self.tail=inserted),null===inserted.prev&&(self.head=inserted),self.length++,inserted}function push(self,item){self.tail=new Node(item,self.tail,null,self),self.head||(self.head=self.tail),self.length++}function unshift(self,item){self.head=new Node(item,null,self.head,self),self.tail||(self.tail=self.head),self.length++}function Node(value,prev,next,list){if(!(this instanceof Node))return new Node(value,prev,next,list);this.list=list,this.value=value,prev?(prev.next=this,this.prev=prev):this.prev=null,next?(next.prev=this,this.next=next):this.next=null}module.exports=Yallist,Yallist.Node=Node,Yallist.create=Yallist,Yallist.prototype.removeNode=function(node){if(node.list!==this)throw new Error("removing node which does not belong to this list");var next=node.next,prev=node.prev;return next&&(next.prev=prev),prev&&(prev.next=next),node===this.head&&(this.head=next),node===this.tail&&(this.tail=prev),node.list.length--,node.next=null,node.prev=null,node.list=null,next},Yallist.prototype.unshiftNode=function(node){if(node!==this.head){node.list&&node.list.removeNode(node);var head=this.head;node.list=this,node.next=head,head&&(head.prev=node),this.head=node,this.tail||(this.tail=node),this.length++}},Yallist.prototype.pushNode=function(node){if(node!==this.tail){node.list&&node.list.removeNode(node);var tail=this.tail;node.list=this,node.prev=tail,tail&&(tail.next=node),this.tail=node,this.head||(this.head=node),this.length++}},Yallist.prototype.push=function(){for(var i=0,l=arguments.length;i<l;i++)push(this,arguments[i]);return this.length},Yallist.prototype.unshift=function(){for(var i=0,l=arguments.length;i<l;i++)unshift(this,arguments[i]);return this.length},Yallist.prototype.pop=function(){if(this.tail){var res=this.tail.value;return this.tail=this.tail.prev,this.tail?this.tail.next=null:this.head=null,this.length--,res}},Yallist.prototype.shift=function(){if(this.head){var res=this.head.value;return this.head=this.head.next,this.head?this.head.prev=null:this.tail=null,this.length--,res}},Yallist.prototype.forEach=function(fn,thisp){thisp=thisp||this;for(var walker=this.head,i=0;null!==walker;i++)fn.call(thisp,walker.value,i,this),walker=walker.next},Yallist.prototype.forEachReverse=function(fn,thisp){thisp=thisp||this;for(var walker=this.tail,i=this.length-1;null!==walker;i--)fn.call(thisp,walker.value,i,this),walker=walker.prev},Yallist.prototype.get=function(n){for(var i=0,walker=this.head;null!==walker&&i<n;i++)walker=walker.next;if(i===n&&null!==walker)return walker.value},Yallist.prototype.getReverse=function(n){for(var i=0,walker=this.tail;null!==walker&&i<n;i++)walker=walker.prev;if(i===n&&null!==walker)return walker.value},Yallist.prototype.map=function(fn,thisp){thisp=thisp||this;for(var res=new Yallist,walker=this.head;null!==walker;)res.push(fn.call(thisp,walker.value,this)),walker=walker.next;return res},Yallist.prototype.mapReverse=function(fn,thisp){thisp=thisp||this;for(var res=new Yallist,walker=this.tail;null!==walker;)res.push(fn.call(thisp,walker.value,this)),walker=walker.prev;return res},Yallist.prototype.reduce=function(fn,initial){var acc,walker=this.head;if(arguments.length>1)acc=initial;else{if(!this.head)throw new TypeError("Reduce of empty list with no initial value");walker=this.head.next,acc=this.head.value}for(var i=0;null!==walker;i++)acc=fn(acc,walker.value,i),walker=walker.next;return acc},Yallist.prototype.reduceReverse=function(fn,initial){var acc,walker=this.tail;if(arguments.length>1)acc=initial;else{if(!this.tail)throw new TypeError("Reduce of empty list with no initial value");walker=this.tail.prev,acc=this.tail.value}for(var i=this.length-1;null!==walker;i--)acc=fn(acc,walker.value,i),walker=walker.prev;return acc},Yallist.prototype.toArray=function(){for(var arr=new Array(this.length),i=0,walker=this.head;null!==walker;i++)arr[i]=walker.value,walker=walker.next;return arr},Yallist.prototype.toArrayReverse=function(){for(var arr=new Array(this.length),i=0,walker=this.tail;null!==walker;i++)arr[i]=walker.value,walker=walker.prev;return arr},Yallist.prototype.slice=function(from,to){(to=to||this.length)<0&&(to+=this.length),(from=from||0)<0&&(from+=this.length);var ret=new Yallist;if(to<from||to<0)return ret;from<0&&(from=0),to>this.length&&(to=this.length);for(var i=0,walker=this.head;null!==walker&&i<from;i++)walker=walker.next;for(;null!==walker&&i<to;i++,walker=walker.next)ret.push(walker.value);return ret},Yallist.prototype.sliceReverse=function(from,to){(to=to||this.length)<0&&(to+=this.length),(from=from||0)<0&&(from+=this.length);var ret=new Yallist;if(to<from||to<0)return ret;from<0&&(from=0),to>this.length&&(to=this.length);for(var i=this.length,walker=this.tail;null!==walker&&i>to;i--)walker=walker.prev;for(;null!==walker&&i>from;i--,walker=walker.prev)ret.push(walker.value);return ret},Yallist.prototype.splice=function(start,deleteCount,...nodes){start>this.length&&(start=this.length-1),start<0&&(start=this.length+start);for(var i=0,walker=this.head;null!==walker&&i<start;i++)walker=walker.next;var ret=[];for(i=0;walker&&i<deleteCount;i++)ret.push(walker.value),walker=this.removeNode(walker);null===walker&&(walker=this.tail),walker!==this.head&&walker!==this.tail&&(walker=walker.prev);for(i=0;i<nodes.length;i++)walker=insert(this,walker,nodes[i]);return ret},Yallist.prototype.reverse=function(){for(var head=this.head,tail=this.tail,walker=head;null!==walker;walker=walker.prev){var p=walker.prev;walker.prev=walker.next,walker.next=p}return this.head=tail,this.tail=head,this};try{__webpack_require__("./node_modules/jsonld/node_modules/yallist/iterator.js")(Yallist)}catch(er){}},"./node_modules/rdf-canonize/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{module.exports=__webpack_require__("./node_modules/rdf-canonize/lib/index.js")},"./node_modules/rdf-canonize/lib/IdentifierIssuer.js":module=>{"use strict";module.exports=class IdentifierIssuer{constructor(prefix,existing=new Map,counter=0){this.prefix=prefix,this._existing=existing,this.counter=counter}clone(){const{prefix,_existing,counter}=this;return new IdentifierIssuer(prefix,new Map(_existing),counter)}getId(old){const existing=old&&this._existing.get(old);if(existing)return existing;const identifier=this.prefix+this.counter;return this.counter++,old&&this._existing.set(old,identifier),identifier}hasId(old){return this._existing.has(old)}getOldIds(){return[...this._existing.keys()]}}},"./node_modules/rdf-canonize/lib/MessageDigest-browser.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";__webpack_require__("./node_modules/setimmediate/setImmediate.js");const crypto=self.crypto||self.msCrypto;module.exports=class MessageDigest{constructor(algorithm){if(!crypto||!crypto.subtle)throw new Error("crypto.subtle not found.");if("sha256"===algorithm)this.algorithm={name:"SHA-256"};else{if("sha1"!==algorithm)throw new Error(`Unsupported algorithm "${algorithm}".`);this.algorithm={name:"SHA-1"}}this._content=""}update(msg){this._content+=msg}async digest(){const data=(new TextEncoder).encode(this._content),buffer=new Uint8Array(await crypto.subtle.digest(this.algorithm,data));let hex="";for(let i=0;i<buffer.length;++i)hex+=buffer[i].toString(16).padStart(2,"0");return hex}}},"./node_modules/rdf-canonize/lib/NQuads.js":module=>{"use strict";const RDF_LANGSTRING="http://www.w3.org/1999/02/22-rdf-syntax-ns#langString",XSD_STRING="http://www.w3.org/2001/XMLSchema#string",REGEX={};function _compareTriples(t1,t2){return t1.subject.termType===t2.subject.termType&&t1.object.termType===t2.object.termType&&(t1.subject.value===t2.subject.value&&t1.predicate.value===t2.predicate.value&&t1.object.value===t2.object.value&&("Literal"!==t1.object.termType||t1.object.datatype.termType===t2.object.datatype.termType&&t1.object.language===t2.object.language&&t1.object.datatype.value===t2.object.datatype.value))}(()=>{const iri="(?:<([^:]+:[^>]*)>)",PN_CHARS_U="A-Za-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�_",PN_CHARS=PN_CHARS_U+"0-9-·̀-ͯ‿-⁀",BLANK_NODE_LABEL="(_:(?:["+PN_CHARS_U+"0-9])(?:(?:["+PN_CHARS+".])*(?:["+PN_CHARS+"]))?)",wso="[ \\t]*",subject="(?:"+iri+"|"+BLANK_NODE_LABEL+")[ \\t]+",property=iri+"[ \\t]+",object="(?:"+iri+"|"+BLANK_NODE_LABEL+"|"+('(?:"([^"\\\\]*(?:\\\\.[^"\\\\]*)*)"(?:'+("(?:\\^\\^"+iri+")")+"|(?:@([a-zA-Z]+(?:-[a-zA-Z0-9]+)*)))?)")+")"+wso,graphName="(?:\\.|(?:(?:"+iri+"|"+BLANK_NODE_LABEL+")"+wso+"\\.))";REGEX.eoln=/(?:\r\n)|(?:\n)|(?:\r)/g,REGEX.empty=new RegExp("^[ \\t]*$"),REGEX.quad=new RegExp("^"+wso+subject+property+object+graphName+wso+"$")})(),module.exports=class NQuads{static parse(input){const dataset=[],graphs={},lines=input.split(REGEX.eoln);let lineNumber=0;for(const line of lines){if(lineNumber++,REGEX.empty.test(line))continue;const match=line.match(REGEX.quad);if(null===match)throw new Error("N-Quads parse error on line "+lineNumber+".");const quad={subject:null,predicate:null,object:null,graph:null};if(void 0!==match[1]?quad.subject={termType:"NamedNode",value:match[1]}:quad.subject={termType:"BlankNode",value:match[2]},quad.predicate={termType:"NamedNode",value:match[3]},void 0!==match[4]?quad.object={termType:"NamedNode",value:match[4]}:void 0!==match[5]?quad.object={termType:"BlankNode",value:match[5]}:(quad.object={termType:"Literal",value:void 0,datatype:{termType:"NamedNode"}},void 0!==match[7]?quad.object.datatype.value=match[7]:void 0!==match[8]?(quad.object.datatype.value=RDF_LANGSTRING,quad.object.language=match[8]):quad.object.datatype.value=XSD_STRING,quad.object.value=match[6].replace(_unescapeRegex,(function(match,code,u,U){if(code)switch(code){case"t":return"\t";case"b":return"\b";case"n":return"\n";case"r":return"\r";case"f":return"\f";case'"':return'"';case"'":return"'";case"\\":return"\\"}if(u)return String.fromCharCode(parseInt(u,16));if(U)throw new Error("Unsupported U escape")}))),void 0!==match[9]?quad.graph={termType:"NamedNode",value:match[9]}:void 0!==match[10]?quad.graph={termType:"BlankNode",value:match[10]}:quad.graph={termType:"DefaultGraph",value:""},quad.graph.value in graphs){let unique=!0;const quads=graphs[quad.graph.value];for(const q of quads)if(_compareTriples(q,quad)){unique=!1;break}unique&&(quads.push(quad),dataset.push(quad))}else graphs[quad.graph.value]=[quad],dataset.push(quad)}return dataset}static serialize(dataset){Array.isArray(dataset)||(dataset=NQuads.legacyDatasetToQuads(dataset));const quads=[];for(const quad of dataset)quads.push(NQuads.serializeQuad(quad));return quads.sort().join("")}static serializeQuadComponents(s,p,o,g){let nquad="";return"NamedNode"===s.termType?nquad+=`<${s.value}>`:nquad+=`${s.value}`,nquad+=` <${p.value}> `,"NamedNode"===o.termType?nquad+=`<${o.value}>`:"BlankNode"===o.termType?nquad+=o.value:(nquad+=`"${function _escape(s){return s.replace(_escapeRegex,(function(match){switch(match){case'"':return'\\"';case"\\":return"\\\\";case"\n":return"\\n";case"\r":return"\\r"}}))}(o.value)}"`,o.datatype.value===RDF_LANGSTRING?o.language&&(nquad+=`@${o.language}`):o.datatype.value!==XSD_STRING&&(nquad+=`^^<${o.datatype.value}>`)),"NamedNode"===g.termType?nquad+=` <${g.value}>`:"BlankNode"===g.termType&&(nquad+=` ${g.value}`),nquad+=" .\n",nquad}static serializeQuad(quad){return NQuads.serializeQuadComponents(quad.subject,quad.predicate,quad.object,quad.graph)}static legacyDatasetToQuads(dataset){const quads=[],termTypeMap={"blank node":"BlankNode",IRI:"NamedNode",literal:"Literal"};for(const graphName in dataset){dataset[graphName].forEach((triple=>{const quad={};for(const componentName in triple){const oldComponent=triple[componentName],newComponent={termType:termTypeMap[oldComponent.type],value:oldComponent.value};"Literal"===newComponent.termType&&(newComponent.datatype={termType:"NamedNode"},"datatype"in oldComponent&&(newComponent.datatype.value=oldComponent.datatype),"language"in oldComponent?("datatype"in oldComponent||(newComponent.datatype.value=RDF_LANGSTRING),newComponent.language=oldComponent.language):"datatype"in oldComponent||(newComponent.datatype.value=XSD_STRING)),quad[componentName]=newComponent}quad.graph="@default"===graphName?{termType:"DefaultGraph",value:""}:{termType:graphName.startsWith("_:")?"BlankNode":"NamedNode",value:graphName},quads.push(quad)}))}return quads}};const _escapeRegex=/["\\\n\r]/g;const _unescapeRegex=/(?:\\([tbnrf"'\\]))|(?:\\u([0-9A-Fa-f]{4}))|(?:\\U([0-9A-Fa-f]{8}))/g},"./node_modules/rdf-canonize/lib/Permuter.js":module=>{"use strict";module.exports=class Permuter{constructor(list){this.current=list.sort(),this.done=!1,this.dir=new Map;for(let i=0;i<list.length;++i)this.dir.set(list[i],!0)}hasNext(){return!this.done}next(){const{current,dir}=this,rval=current.slice();let k=null,pos=0;const length=current.length;for(let i=0;i<length;++i){const element=current[i],left=dir.get(element);(null===k||element>k)&&(left&&i>0&&element>current[i-1]||!left&&i<length-1&&element>current[i+1])&&(k=element,pos=i)}if(null===k)this.done=!0;else{const swap=dir.get(k)?pos-1:pos+1;current[pos]=current[swap],current[swap]=k;for(const element of current)element>k&&dir.set(element,!dir.get(element))}return rval}}},"./node_modules/rdf-canonize/lib/URDNA2015.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";const IdentifierIssuer=__webpack_require__("./node_modules/rdf-canonize/lib/IdentifierIssuer.js"),MessageDigest=__webpack_require__("./node_modules/rdf-canonize/lib/MessageDigest-browser.js"),Permuter=__webpack_require__("./node_modules/rdf-canonize/lib/Permuter.js"),NQuads=__webpack_require__("./node_modules/rdf-canonize/lib/NQuads.js");function _stringHashCompare(a,b){return a.hash<b.hash?-1:a.hash>b.hash?1:0}module.exports=class URDNA2015{constructor({createMessageDigest=()=>new MessageDigest("sha256"),canonicalIdMap=new Map,maxDeepIterations=1/0}={}){this.name="URDNA2015",this.blankNodeInfo=new Map,this.canonicalIssuer=new IdentifierIssuer("_:c14n",canonicalIdMap),this.createMessageDigest=createMessageDigest,this.maxDeepIterations=maxDeepIterations,this.quads=null,this.deepIterations=null}async main(dataset){this.deepIterations=new Map,this.quads=dataset;for(const quad of dataset)this._addBlankNodeQuadInfo({quad,component:quad.subject}),this._addBlankNodeQuadInfo({quad,component:quad.object}),this._addBlankNodeQuadInfo({quad,component:quad.graph});const hashToBlankNodes=new Map,nonNormalized=[...this.blankNodeInfo.keys()];let i=0;for(const id of nonNormalized)++i%100==0&&await this._yield(),await this._hashAndTrackBlankNode({id,hashToBlankNodes});const hashes=[...hashToBlankNodes.keys()].sort(),nonUnique=[];for(const hash of hashes){const idList=hashToBlankNodes.get(hash);if(idList.length>1){nonUnique.push(idList);continue}const id=idList[0];this.canonicalIssuer.getId(id)}for(const idList of nonUnique){const hashPathList=[];for(const id of idList){if(this.canonicalIssuer.hasId(id))continue;const issuer=new IdentifierIssuer("_:b");issuer.getId(id);const result=await this.hashNDegreeQuads(id,issuer);hashPathList.push(result)}hashPathList.sort(_stringHashCompare);for(const result of hashPathList){const oldIds=result.issuer.getOldIds();for(const id of oldIds)this.canonicalIssuer.getId(id)}}const normalized=[];for(const quad of this.quads){const nQuad=NQuads.serializeQuadComponents(this._componentWithCanonicalId(quad.subject),quad.predicate,this._componentWithCanonicalId(quad.object),this._componentWithCanonicalId(quad.graph));normalized.push(nQuad)}return normalized.sort(),normalized.join("")}async hashFirstDegreeQuads(id){const nquads=[],info=this.blankNodeInfo.get(id),quads=info.quads;for(const quad of quads){const copy={subject:null,predicate:quad.predicate,object:null,graph:null};copy.subject=this.modifyFirstDegreeComponent(id,quad.subject,"subject"),copy.object=this.modifyFirstDegreeComponent(id,quad.object,"object"),copy.graph=this.modifyFirstDegreeComponent(id,quad.graph,"graph"),nquads.push(NQuads.serializeQuad(copy))}nquads.sort();const md=this.createMessageDigest();for(const nquad of nquads)md.update(nquad);return info.hash=await md.digest(),info.hash}async hashRelatedBlankNode(related,quad,issuer,position){let id;id=this.canonicalIssuer.hasId(related)?this.canonicalIssuer.getId(related):issuer.hasId(related)?issuer.getId(related):this.blankNodeInfo.get(related).hash;const md=this.createMessageDigest();return md.update(position),"g"!==position&&md.update(this.getRelatedPredicate(quad)),md.update(id),md.digest()}async hashNDegreeQuads(id,issuer){const deepIterations=this.deepIterations.get(id)||0;if(deepIterations>this.maxDeepIterations)throw new Error(`Maximum deep iterations (${this.maxDeepIterations}) exceeded.`);this.deepIterations.set(id,deepIterations+1);const md=this.createMessageDigest(),hashToRelated=await this.createHashToRelated(id,issuer),hashes=[...hashToRelated.keys()].sort();for(const hash of hashes){md.update(hash);let chosenIssuer,chosenPath="";const permuter=new Permuter(hashToRelated.get(hash));let i=0;for(;permuter.hasNext();){const permutation=permuter.next();++i%3==0&&await this._yield();let issuerCopy=issuer.clone(),path="";const recursionList=[];let nextPermutation=!1;for(const related of permutation)if(this.canonicalIssuer.hasId(related)?path+=this.canonicalIssuer.getId(related):(issuerCopy.hasId(related)||recursionList.push(related),path+=issuerCopy.getId(related)),0!==chosenPath.length&&path>chosenPath){nextPermutation=!0;break}if(!nextPermutation){for(const related of recursionList){const result=await this.hashNDegreeQuads(related,issuerCopy);if(path+=issuerCopy.getId(related),path+=`<${result.hash}>`,issuerCopy=result.issuer,0!==chosenPath.length&&path>chosenPath){nextPermutation=!0;break}}nextPermutation||(0===chosenPath.length||path<chosenPath)&&(chosenPath=path,chosenIssuer=issuerCopy)}}md.update(chosenPath),issuer=chosenIssuer}return{hash:await md.digest(),issuer}}modifyFirstDegreeComponent(id,component){return"BlankNode"!==component.termType?component:{termType:"BlankNode",value:component.value===id?"_:a":"_:z"}}getRelatedPredicate(quad){return`<${quad.predicate.value}>`}async createHashToRelated(id,issuer){const hashToRelated=new Map,quads=this.blankNodeInfo.get(id).quads;let i=0;for(const quad of quads)++i%100==0&&await this._yield(),await Promise.all([this._addRelatedBlankNodeHash({quad,component:quad.subject,position:"s",id,issuer,hashToRelated}),this._addRelatedBlankNodeHash({quad,component:quad.object,position:"o",id,issuer,hashToRelated}),this._addRelatedBlankNodeHash({quad,component:quad.graph,position:"g",id,issuer,hashToRelated})]);return hashToRelated}async _hashAndTrackBlankNode({id,hashToBlankNodes}){const hash=await this.hashFirstDegreeQuads(id),idList=hashToBlankNodes.get(hash);idList?idList.push(id):hashToBlankNodes.set(hash,[id])}_addBlankNodeQuadInfo({quad,component}){if("BlankNode"!==component.termType)return;const id=component.value,info=this.blankNodeInfo.get(id);info?info.quads.add(quad):this.blankNodeInfo.set(id,{quads:new Set([quad]),hash:null})}async _addRelatedBlankNodeHash({quad,component,position,id,issuer,hashToRelated}){if("BlankNode"!==component.termType||component.value===id)return;const related=component.value,hash=await this.hashRelatedBlankNode(related,quad,issuer,position),entries=hashToRelated.get(hash);entries?entries.push(related):hashToRelated.set(hash,[related])}_componentWithCanonicalId(component){return"BlankNode"!==component.termType||component.value.startsWith(this.canonicalIssuer.prefix)?component:{termType:"BlankNode",value:this.canonicalIssuer.getId(component.value)}}async _yield(){return new Promise((resolve=>setImmediate(resolve)))}}},"./node_modules/rdf-canonize/lib/URDNA2015Sync.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";const IdentifierIssuer=__webpack_require__("./node_modules/rdf-canonize/lib/IdentifierIssuer.js"),MessageDigest=__webpack_require__("./node_modules/rdf-canonize/lib/MessageDigest-browser.js"),Permuter=__webpack_require__("./node_modules/rdf-canonize/lib/Permuter.js"),NQuads=__webpack_require__("./node_modules/rdf-canonize/lib/NQuads.js");function _stringHashCompare(a,b){return a.hash<b.hash?-1:a.hash>b.hash?1:0}module.exports=class URDNA2015Sync{constructor({createMessageDigest=()=>new MessageDigest("sha256"),canonicalIdMap=new Map,maxDeepIterations=1/0}={}){this.name="URDNA2015",this.blankNodeInfo=new Map,this.canonicalIssuer=new IdentifierIssuer("_:c14n",canonicalIdMap),this.createMessageDigest=createMessageDigest,this.maxDeepIterations=maxDeepIterations,this.quads=null,this.deepIterations=null}main(dataset){this.deepIterations=new Map,this.quads=dataset;for(const quad of dataset)this._addBlankNodeQuadInfo({quad,component:quad.subject}),this._addBlankNodeQuadInfo({quad,component:quad.object}),this._addBlankNodeQuadInfo({quad,component:quad.graph});const hashToBlankNodes=new Map,nonNormalized=[...this.blankNodeInfo.keys()];for(const id of nonNormalized)this._hashAndTrackBlankNode({id,hashToBlankNodes});const hashes=[...hashToBlankNodes.keys()].sort(),nonUnique=[];for(const hash of hashes){const idList=hashToBlankNodes.get(hash);if(idList.length>1){nonUnique.push(idList);continue}const id=idList[0];this.canonicalIssuer.getId(id)}for(const idList of nonUnique){const hashPathList=[];for(const id of idList){if(this.canonicalIssuer.hasId(id))continue;const issuer=new IdentifierIssuer("_:b");issuer.getId(id);const result=this.hashNDegreeQuads(id,issuer);hashPathList.push(result)}hashPathList.sort(_stringHashCompare);for(const result of hashPathList){const oldIds=result.issuer.getOldIds();for(const id of oldIds)this.canonicalIssuer.getId(id)}}const normalized=[];for(const quad of this.quads){const nQuad=NQuads.serializeQuadComponents(this._componentWithCanonicalId({component:quad.subject}),quad.predicate,this._componentWithCanonicalId({component:quad.object}),this._componentWithCanonicalId({component:quad.graph}));normalized.push(nQuad)}return normalized.sort(),normalized.join("")}hashFirstDegreeQuads(id){const nquads=[],info=this.blankNodeInfo.get(id),quads=info.quads;for(const quad of quads){const copy={subject:null,predicate:quad.predicate,object:null,graph:null};copy.subject=this.modifyFirstDegreeComponent(id,quad.subject,"subject"),copy.object=this.modifyFirstDegreeComponent(id,quad.object,"object"),copy.graph=this.modifyFirstDegreeComponent(id,quad.graph,"graph"),nquads.push(NQuads.serializeQuad(copy))}nquads.sort();const md=this.createMessageDigest();for(const nquad of nquads)md.update(nquad);return info.hash=md.digest(),info.hash}hashRelatedBlankNode(related,quad,issuer,position){let id;id=this.canonicalIssuer.hasId(related)?this.canonicalIssuer.getId(related):issuer.hasId(related)?issuer.getId(related):this.blankNodeInfo.get(related).hash;const md=this.createMessageDigest();return md.update(position),"g"!==position&&md.update(this.getRelatedPredicate(quad)),md.update(id),md.digest()}hashNDegreeQuads(id,issuer){const deepIterations=this.deepIterations.get(id)||0;if(deepIterations>this.maxDeepIterations)throw new Error(`Maximum deep iterations (${this.maxDeepIterations}) exceeded.`);this.deepIterations.set(id,deepIterations+1);const md=this.createMessageDigest(),hashToRelated=this.createHashToRelated(id,issuer),hashes=[...hashToRelated.keys()].sort();for(const hash of hashes){md.update(hash);let chosenIssuer,chosenPath="";const permuter=new Permuter(hashToRelated.get(hash));for(;permuter.hasNext();){const permutation=permuter.next();let issuerCopy=issuer.clone(),path="";const recursionList=[];let nextPermutation=!1;for(const related of permutation)if(this.canonicalIssuer.hasId(related)?path+=this.canonicalIssuer.getId(related):(issuerCopy.hasId(related)||recursionList.push(related),path+=issuerCopy.getId(related)),0!==chosenPath.length&&path>chosenPath){nextPermutation=!0;break}if(!nextPermutation){for(const related of recursionList){const result=this.hashNDegreeQuads(related,issuerCopy);if(path+=issuerCopy.getId(related),path+=`<${result.hash}>`,issuerCopy=result.issuer,0!==chosenPath.length&&path>chosenPath){nextPermutation=!0;break}}nextPermutation||(0===chosenPath.length||path<chosenPath)&&(chosenPath=path,chosenIssuer=issuerCopy)}}md.update(chosenPath),issuer=chosenIssuer}return{hash:md.digest(),issuer}}modifyFirstDegreeComponent(id,component){return"BlankNode"!==component.termType?component:{termType:"BlankNode",value:component.value===id?"_:a":"_:z"}}getRelatedPredicate(quad){return`<${quad.predicate.value}>`}createHashToRelated(id,issuer){const hashToRelated=new Map,quads=this.blankNodeInfo.get(id).quads;for(const quad of quads)this._addRelatedBlankNodeHash({quad,component:quad.subject,position:"s",id,issuer,hashToRelated}),this._addRelatedBlankNodeHash({quad,component:quad.object,position:"o",id,issuer,hashToRelated}),this._addRelatedBlankNodeHash({quad,component:quad.graph,position:"g",id,issuer,hashToRelated});return hashToRelated}_hashAndTrackBlankNode({id,hashToBlankNodes}){const hash=this.hashFirstDegreeQuads(id),idList=hashToBlankNodes.get(hash);idList?idList.push(id):hashToBlankNodes.set(hash,[id])}_addBlankNodeQuadInfo({quad,component}){if("BlankNode"!==component.termType)return;const id=component.value,info=this.blankNodeInfo.get(id);info?info.quads.add(quad):this.blankNodeInfo.set(id,{quads:new Set([quad]),hash:null})}_addRelatedBlankNodeHash({quad,component,position,id,issuer,hashToRelated}){if("BlankNode"!==component.termType||component.value===id)return;const related=component.value,hash=this.hashRelatedBlankNode(related,quad,issuer,position),entries=hashToRelated.get(hash);entries?entries.push(related):hashToRelated.set(hash,[related])}_componentWithCanonicalId({component}){return"BlankNode"!==component.termType||component.value.startsWith(this.canonicalIssuer.prefix)?component:{termType:"BlankNode",value:this.canonicalIssuer.getId(component.value)}}}},"./node_modules/rdf-canonize/lib/URGNA2012.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";const MessageDigest=__webpack_require__("./node_modules/rdf-canonize/lib/MessageDigest-browser.js"),URDNA2015=__webpack_require__("./node_modules/rdf-canonize/lib/URDNA2015.js");module.exports=class URDNA2012 extends URDNA2015{constructor(){super(),this.name="URGNA2012",this.createMessageDigest=()=>new MessageDigest("sha1")}modifyFirstDegreeComponent(id,component,key){return"BlankNode"!==component.termType?component:"graph"===key?{termType:"BlankNode",value:"_:g"}:{termType:"BlankNode",value:component.value===id?"_:a":"_:z"}}getRelatedPredicate(quad){return quad.predicate.value}async createHashToRelated(id,issuer){const hashToRelated=new Map,quads=this.blankNodeInfo.get(id).quads;let i=0;for(const quad of quads){let position,related;if("BlankNode"===quad.subject.termType&&quad.subject.value!==id)related=quad.subject.value,position="p";else{if("BlankNode"!==quad.object.termType||quad.object.value===id)continue;related=quad.object.value,position="r"}++i%100==0&&await this._yield();const hash=await this.hashRelatedBlankNode(related,quad,issuer,position),entries=hashToRelated.get(hash);entries?entries.push(related):hashToRelated.set(hash,[related])}return hashToRelated}}},"./node_modules/rdf-canonize/lib/URGNA2012Sync.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";const MessageDigest=__webpack_require__("./node_modules/rdf-canonize/lib/MessageDigest-browser.js"),URDNA2015Sync=__webpack_require__("./node_modules/rdf-canonize/lib/URDNA2015Sync.js");module.exports=class URDNA2012Sync extends URDNA2015Sync{constructor(){super(),this.name="URGNA2012",this.createMessageDigest=()=>new MessageDigest("sha1")}modifyFirstDegreeComponent(id,component,key){return"BlankNode"!==component.termType?component:"graph"===key?{termType:"BlankNode",value:"_:g"}:{termType:"BlankNode",value:component.value===id?"_:a":"_:z"}}getRelatedPredicate(quad){return quad.predicate.value}createHashToRelated(id,issuer){const hashToRelated=new Map,quads=this.blankNodeInfo.get(id).quads;for(const quad of quads){let position,related;if("BlankNode"===quad.subject.termType&&quad.subject.value!==id)related=quad.subject.value,position="p";else{if("BlankNode"!==quad.object.termType||quad.object.value===id)continue;related=quad.object.value,position="r"}const hash=this.hashRelatedBlankNode(related,quad,issuer,position),entries=hashToRelated.get(hash);entries?entries.push(related):hashToRelated.set(hash,[related])}return hashToRelated}}},"./node_modules/rdf-canonize/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";const URDNA2015=__webpack_require__("./node_modules/rdf-canonize/lib/URDNA2015.js"),URGNA2012=__webpack_require__("./node_modules/rdf-canonize/lib/URGNA2012.js"),URDNA2015Sync=__webpack_require__("./node_modules/rdf-canonize/lib/URDNA2015Sync.js"),URGNA2012Sync=__webpack_require__("./node_modules/rdf-canonize/lib/URGNA2012Sync.js");let rdfCanonizeNative;try{rdfCanonizeNative=__webpack_require__("?2b19")}catch(e){}function _inputToDataset(input){return Array.isArray(input)?input:exports.NQuads.legacyDatasetToQuads(input)}exports.NQuads=__webpack_require__("./node_modules/rdf-canonize/lib/NQuads.js"),exports.IdentifierIssuer=__webpack_require__("./node_modules/rdf-canonize/lib/IdentifierIssuer.js"),exports._rdfCanonizeNative=function(api){return api&&(rdfCanonizeNative=api),rdfCanonizeNative},exports.canonize=async function(input,options){const dataset=_inputToDataset(input);if(options.useNative){if(!rdfCanonizeNative)throw new Error("rdf-canonize-native not available");if(options.createMessageDigest)throw new Error('"createMessageDigest" cannot be used with "useNative".');return new Promise(((resolve,reject)=>rdfCanonizeNative.canonize(dataset,options,((err,canonical)=>err?reject(err):resolve(canonical)))))}if("URDNA2015"===options.algorithm)return new URDNA2015(options).main(dataset);if("URGNA2012"===options.algorithm){if(options.createMessageDigest)throw new Error('"createMessageDigest" cannot be used with "URGNA2012".');return new URGNA2012(options).main(dataset)}if(!("algorithm"in options))throw new Error("No RDF Dataset Canonicalization algorithm specified.");throw new Error("Invalid RDF Dataset Canonicalization algorithm: "+options.algorithm)},exports._canonizeSync=function(input,options){const dataset=_inputToDataset(input);if(options.useNative){if(!rdfCanonizeNative)throw new Error("rdf-canonize-native not available");if(options.createMessageDigest)throw new Error('"createMessageDigest" cannot be used with "useNative".');return rdfCanonizeNative.canonizeSync(dataset,options)}if("URDNA2015"===options.algorithm)return new URDNA2015Sync(options).main(dataset);if("URGNA2012"===options.algorithm){if(options.createMessageDigest)throw new Error('"createMessageDigest" cannot be used with "URGNA2012".');return new URGNA2012Sync(options).main(dataset)}if(!("algorithm"in options))throw new Error("No RDF Dataset Canonicalization algorithm specified.");throw new Error("Invalid RDF Dataset Canonicalization algorithm: "+options.algorithm)}},"./node_modules/setimmediate/setImmediate.js":function(__unused_webpack_module,__unused_webpack_exports,__webpack_require__){var process=__webpack_require__("./node_modules/process/browser.js");!function(global){"use strict";if(!global.setImmediate){var registerImmediate,nextHandle=1,tasksByHandle={},currentlyRunningATask=!1,doc=global.document,attachTo=Object.getPrototypeOf&&Object.getPrototypeOf(global);attachTo=attachTo&&attachTo.setTimeout?attachTo:global,"[object process]"==={}.toString.call(global.process)?function installNextTickImplementation(){registerImmediate=function(handle){process.nextTick((function(){runIfPresent(handle)}))}}():!function canUsePostMessage(){if(global.postMessage&&!global.importScripts){var postMessageIsAsynchronous=!0,oldOnMessage=global.onmessage;return global.onmessage=function(){postMessageIsAsynchronous=!1},global.postMessage("","*"),global.onmessage=oldOnMessage,postMessageIsAsynchronous}}()?global.MessageChannel?function installMessageChannelImplementation(){var channel=new MessageChannel;channel.port1.onmessage=function(event){runIfPresent(event.data)},registerImmediate=function(handle){channel.port2.postMessage(handle)}}():doc&&"onreadystatechange"in doc.createElement("script")?function installReadyStateChangeImplementation(){var html=doc.documentElement;registerImmediate=function(handle){var script=doc.createElement("script");script.onreadystatechange=function(){runIfPresent(handle),script.onreadystatechange=null,html.removeChild(script),script=null},html.appendChild(script)}}():function installSetTimeoutImplementation(){registerImmediate=function(handle){setTimeout(runIfPresent,0,handle)}}():function installPostMessageImplementation(){var messagePrefix="setImmediate$"+Math.random()+"$",onGlobalMessage=function(event){event.source===global&&"string"==typeof event.data&&0===event.data.indexOf(messagePrefix)&&runIfPresent(+event.data.slice(messagePrefix.length))};global.addEventListener?global.addEventListener("message",onGlobalMessage,!1):global.attachEvent("onmessage",onGlobalMessage),registerImmediate=function(handle){global.postMessage(messagePrefix+handle,"*")}}(),attachTo.setImmediate=function setImmediate(callback){"function"!=typeof callback&&(callback=new Function(""+callback));for(var args=new Array(arguments.length-1),i=0;i<args.length;i++)args[i]=arguments[i+1];var task={callback,args};return tasksByHandle[nextHandle]=task,registerImmediate(nextHandle),nextHandle++},attachTo.clearImmediate=clearImmediate}function clearImmediate(handle){delete tasksByHandle[handle]}function runIfPresent(handle){if(currentlyRunningATask)setTimeout(runIfPresent,0,handle);else{var task=tasksByHandle[handle];if(task){currentlyRunningATask=!0;try{!function run(task){var callback=task.callback,args=task.args;switch(args.length){case 0:callback();break;case 1:callback(args[0]);break;case 2:callback(args[0],args[1]);break;case 3:callback(args[0],args[1],args[2]);break;default:callback.apply(void 0,args)}}(task)}finally{clearImmediate(handle),currentlyRunningATask=!1}}}}}("undefined"==typeof self?void 0===__webpack_require__.g?this:__webpack_require__.g:self)}}]);